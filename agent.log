[2025-05-16T14:27:52.167Z] INFO: üöÄ Server running at http://localhost:8000
[2025-05-16T14:28:00.469Z] INFO: üîî Received Jira story: JIRA-Bitcoin-Notifications - As a User, I want to receive rule-based email notifications for Bitcoin buy/sell signals based on technical analysis of its latest price data, so that I can make informed trading decisions
[2025-05-16T14:28:00.470Z] INFO: 
üöÄ Starting LangGraph-style agent orchestration...
[2025-05-16T14:28:15.881Z] INFO: üß† Gemini Prompt Sent:
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: As a User, I want to receive rule-based email notifications for Bitcoin buy/sell signals based on technical analysis of its latest price data, so that I can make informed trading decisions
Description: As a crypto enthusiast, I need an automated system to facilitate informed trading decisions. This system must fetch the latest Bitcoin (BTC) price data (e.g., BTC/USD, including Open, High, Low, Close, and Volume if available) from a documented, free, and publicly accessible online API (specific API like CoinGecko or CoinCap to be chosen during development based on reliability and terms of service). Price data should be fetched at a regular, configurable interval, defaulting to every 15 minutes for this POC.

The core of the system will be a rule engine that analyzes this price data to generate buy and sell signals. A 'Strong Buy' signal should be generated if at least 3 of the 5 defined buy conditions are met, and a 'Strong Sell' signal if at least 3 of the 5 defined sell conditions are met. All parameters for the technical indicators (periods, levels) must be configurable, with the following defaults and rules:
1.  Moving Average (MA) Crossover: A buy signal occurs when a short-term Exponential Moving Average (EMA), default 20-period, crosses above a long-term EMA, default 50-period. A sell signal occurs when the short-term EMA crosses below the long-term EMA.
2.  Relative Strength Index (RSI): A potential buy signal is indicated when the 14-period RSI crosses above the 30 level (oversold threshold) from below. A potential sell signal is indicated when the RSI crosses below the 70 level (overbought threshold) from above.
3.  Moving Average Convergence Divergence (MACD): Using default periods (12, 26, 9), a buy signal occurs when the MACD line crosses above its Signal line, ideally when both are below the zero line or the MACD line itself is crossing above zero. A sell signal occurs when the MACD line crosses below the Signal line, ideally when both are above the zero line or the MACD line is crossing below zero.
4.  Bollinger Bands: Using default 20-period and 2 standard deviations, a potential buy signal (reversal) occurs if the price touches or breaks below the lower Bollinger Band and then closes back inside the band, ideally confirmed with volume. A potential sell signal (reversal) occurs if the price touches or breaks above the upper Bollinger Band and then closes back inside, also ideally confirmed with volume.
5.  Volume Confirmation: Any buy or sell signals generated by the other indicators (1-4) are considered stronger if accompanied by a significant increase in trading volume, specifically, volume that is above its 20-period moving average.

Upon generation of a 'Strong Buy' or 'Strong Sell' signal, an email notification must be sent immediately to kesarwanimohit@yahoo.com. The email subject must clearly state 'BITCOIN STRONG [BUY/SELL] Signal Alert'. The email body must include: Signal Type (Strong Buy / Strong Sell), the Date and Time of the signal (preferably AEST, given current context is Australia), the current Bitcoin price at the time of signal generation, and a brief summary of at least 2-3 primary technical indicators that triggered the signal. To avoid excessive notifications, emails for the same signal type (Buy or Sell) should not be sent more frequently than once per configurable period (e.g., default 4 hours), unless the underlying conditions significantly change or reconfirm the signal.

Finally, the system must implement logging for all fetched data points (or a summary), all generated signals (including those not strong enough for notification), and all email notifications that were sent, complete with timestamps for each event. The solution should be developed using NodeJS.

--- EXISTING CONTEXT ---
üîß Backend Routes:
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


üé® Frontend Components:
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


üß™ Test Cases:
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects:
{
  "component": "Frontend" | "Backend" | "ProjectSetup" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation"
}
[2025-05-16T14:28:24.322Z] INFO: ‚úÖ Gemini Output Preview:
```json
[
  {
    "component": "Backend",
    "summary": "Fetch Bitcoin price data from CoinGecko API",
    "description": "Implement a function to fetch BTC/USD price data (Open, High, Low, Close, Volume) from the CoinGecko API at a configurable interval (default 15 minutes). Handle API errors and rate limiting."
  },
  {
    "component": "Backend",
    "summary": "Implement Technical Indicator Calculations",
    "description": "Develop functions to calculate the EMA, RSI, MACD, and Bollinger B
[2025-05-16T14:28:24.323Z] INFO: üìå Planner Output:
```json
[
  {
    "component": "Backend",
    "summary": "Fetch Bitcoin price data from CoinGecko API",
    "description": "Implement a function to fetch BTC/USD price data (Open, High, Low, Close, Volume) from the CoinGecko API at a configurable interval (default 15 minutes). Handle API errors and rate limiting."
  },
  {
    "component": "Backend",
    "summary": "Implement Technical Indicator Calculations",
    "description": "Develop functions to calculate the EMA, RSI, MACD, and Bollinger Bands for the fetched Bitcoin price data.  These functions should accept configurable parameters (periods, levels, standard deviations)."
  },
  {
    "component": "Backend",
    "summary": "Implement Buy/Sell Signal Generation",
    "description": "Create a rule engine that analyzes the calculated technical indicators to generate buy and sell signals based on the specified conditions.  Generate 'Strong Buy' and 'Strong Sell' signals based on at least 3 out of 5 indicator conditions being met."
  },
  {
    "component": "Backend",
    "summary": "Implement Email Notification System",
    "description": "Integrate a Nodemailer (or similar) function to send email notifications to kesarwanimohit@yahoo.com upon generation of a 'Strong Buy' or 'Strong Sell' signal.  The email should include signal type, timestamp (AEST), current price, and a summary of triggering indicators. Implement rate limiting to prevent excessive notifications (default 4 hours)."
  },
  {
    "component": "Backend",
    "summary": "Implement Logging Functionality",
    "description": "Create a logging system (e.g., using Winston or a similar logger) to record all fetched data points, generated signals (including non-'Strong' signals), and sent email notifications, including timestamps."
  },
  {
    "component": "Backend",
    "summary": "Implement Configuration Management",
    "description": "Implement a mechanism to manage configurable parameters (API fetch interval, email notification frequency, technical indicator parameters) either through environment variables or a configuration file."
  },
  {
    "component": "Backend",
    "summary": "Implement AEST Timezone Conversion",
    "description": "Ensure that all timestamps in the application and email notifications are correctly converted to Australian Eastern Standard Time (AEST)."
  },
  {
    "component": "Testing",
    "summary": "Unit Tests for Price Data Fetching",
    "description": "Write unit tests to verify the correct fetching and handling of Bitcoin price data from the CoinGecko API, including error handling and rate limiting."
  },
  {
    "component": "Testing",
    "summary": "Unit Tests for Technical Indicator Calculations",
    "description": "Write unit tests to verify the accuracy of the EMA, RSI, MACD, and Bollinger Bands calculations for various input data sets and parameter configurations."
  },
  {
    "component": "Testing",
    "summary": "Unit Tests for Signal Generation Logic",
    "description": "Write unit tests to verify the correctness of the buy/sell signal generation logic based on different indicator combinations and thresholds."
  },
  {
    "component": "Testing",
    "summary": "Integration Tests for Email Notifications",
    "description": "Write integration tests to simulate sending email notifications and verify the content and formatting of the emails. Consider using a test email service to avoid spamming the actual recipient."
  },
  {
    "component": "Testing",
    "summary": "End-to-End Tests",
    "description": "Develop end-to-end tests to simulate a complete workflow from price data fetching to signal generation and email notification, verifying the entire system's functionality."
  }
]
```

[2025-05-16T14:28:29.660Z] INFO: üîÅ [API - Fetch Bitcoin price data from CoinGecko API] Attempt 1 of 3
[2025-05-16T14:28:29.846Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Implement a function to fetch BTC/USD price data (Open, High, Low, Close, Volume) from the CoinGecko API at a configurable interval (default 15 minutes). Handle API errors and rate limiting.

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:28:35.886Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const axios = require('axios');
const cron = require('node-cron');
const { loadContextFor } = require('./context/contextLoader'); // Use local context loader for testing

const app = express();
const port = 3000;

// Configuration (move to .env or config file in production)
const COINGECKO_API_URL = 'https://api.coingecko.com/api/v3/coins/bitcoin/market_chart';
const UPDATE_INTERVAL_MINUTES = 15; // Default update interval
const DEFAULT_VS_CURREN
[2025-05-16T14:28:35.887Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const axios = require('axios');
const cron = require('node-cron');
const { loadContextFor } = require('./context/contextLoader'); // Use local context loader for testing

const app = express();
const port = 3000;

// Configuration (move to .env or config file in production)
const COINGECKO_API_URL = 'https://api.coingecko.com/api/v3/coins/bitcoin/market_chart';
const UPDATE_INTERVAL_MINUTES = 15; // Default update interval
const DEFAULT_VS_CURRENCY = 'usd';

// In-memory storage for BTC price data (replace with a database in production)
let btcPriceData = {};

// Function to fetch BTC price data from CoinGecko API
async function fetchBtcPriceData(vs_currency = DEFAULT_VS_CURRENCY, days = '1') {
  try {
    const url = `${COINGECKO_API_URL}?vs_currency=${vs_currency}&days=${days}`;
    const response = await axios.get(url);
    return response.data.prices;
  } catch (error) {
    console.error('Error fetching BTC price data:', error.message);
    if (error.response) {
      console.error('Response data:', error.response.data);
      // Handle specific error codes like rate limiting (429)
      if (error.response.status === 429) {
        const retryAfter = error.response.headers['retry-after'];
        console.log(`Rate limit hit. Retrying after ${retryAfter} seconds.`);
        // Implement retry logic here if needed.
      }
    }
    return null; // Return null to indicate failure
  }
}

// API route to get BTC price data
app.get('/api/btc-price', async (req, res) => {
  const vsCurrency = req.query.vs_currency || DEFAULT_VS_CURRENCY;
  const days = req.query.days || '1'; // Allow querying for different time ranges

  if (!btcPriceData[vsCurrency]) {
    btcPriceData[vsCurrency] = await fetchBtcPriceData(vsCurrency, days);
  }

  if (btcPriceData[vsCurrency]) {
    res.json({
      vs_currency: vsCurrency,
      data: btcPriceData[vsCurrency],
    });
  } else {
    res.status(500).json({ error: 'Failed to retrieve BTC price data' });
  }
});

// Scheduled task to update BTC price data
cron.schedule(`*/${UPDATE_INTERVAL_MINUTES} * * * *`, async () => {
  console.log('Updating BTC price data...');
  btcPriceData[DEFAULT_VS_CURRENCY] = await fetchBtcPriceData();
  //Consider adding other currency pairs here.  e.g., btcPriceData['eur'] = await fetchBtcPriceData('eur');
});


//Route to get context (for testing purposes. Remove in production)
app.get('/context/:component', (req, res) => {
  const component = req.params.component;
  const context = loadContextFor(component);
  res.send(context);
});

app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```
[2025-05-16T14:28:35.888Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const axios = require('axios');
const cron = require('node-cron');
const { loadContextFor } = require('./context/contextLoader'); // Use local context loader for testing

const app = express();
const port = 3000;

// Configuration (move to .env or config file in production)
const COINGECKO_API_URL = 'https://api.coingecko.com/api/v3/coins/bitcoin/market_chart';
const UPDATE_INTERVAL_MINUTES = 15; // Default update interval
const DEFAULT_VS_CURRENCY = 'usd';

// In-memory storage for BTC price data (replace with a database in production)
let btcPriceData = {};

// Function to fetch BTC price data from CoinGecko API
async function fetchBtcPriceData(vs_currency = DEFAULT_VS_CURRENCY, days = '1') {
  try {
    const url = `${COINGECKO_API_URL}?vs_currency=${vs_currency}&days=${days}`;
    const response = await axios.get(url);
    return response.data.prices;
  } catch (error) {
    console.error('Error fetching BTC price data:', error.message);
    if (error.response) {
      console.error('Response data:', error.response.data);
      // Handle specific error codes like rate limiting (429)
      if (error.response.status === 429) {
        const retryAfter = error.response.headers['retry-after'];
        console.log(`Rate limit hit. Retrying after ${retryAfter} seconds.`);
        // Implement retry logic here if needed.
      }
    }
    return null; // Return null to indicate failure
  }
}

// API route to get BTC price data
app.get('/api/btc-price', async (req, res) => {
  const vsCurrency = req.query.vs_currency || DEFAULT_VS_CURRENCY;
  const days = req.query.days || '1'; // Allow querying for different time ranges

  if (!btcPriceData[vsCurrency]) {
    btcPriceData[vsCurrency] = await fetchBtcPriceData(vsCurrency, days);
  }

  if (btcPriceData[vsCurrency]) {
    res.json({
      vs_currency: vsCurrency,
      data: btcPriceData[vsCurrency],
    });
  } else {
    res.status(500).json({ error: 'Failed to retrieve BTC price data' });
  }
});

// Scheduled task to update BTC price data
cron.schedule(`*/${UPDATE_INTERVAL_MINUTES} * * * *`, async () => {
  console.log('Updating BTC price data...');
  btcPriceData[DEFAULT_VS_CURRENCY] = await fetchBtcPriceData();
  //Consider adding other currency pairs here.  e.g., btcPriceData['eur'] = await fetchBtcPriceData('eur');
});


//Route to get context (for testing purposes. Remove in production)
app.get('/context/:component', (req, res) => {
  const component = req.params.component;
  const context = loadContextFor(component);
  res.send(context);
});

app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});
[2025-05-16T14:28:35.890Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:28:35.891Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:28:35.906Z] INFO: ‚úÖ Saved: routes/Generated_1_api_fetch_bitcoin_price_data_from_coinge.js
[2025-05-16T14:28:41.414Z] INFO: üîÅ [API - Implement Technical Indicator Calculations] Attempt 1 of 3
[2025-05-16T14:28:41.507Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Develop functions to calculate the EMA, RSI, MACD, and Bollinger Bands for the fetched Bitcoin price data.  These functions should accept configurable parameters (periods, levels, standard deviations).

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:28:50.266Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const app = express();
const port = 3000;
const axios = require('axios');

// Configuration (move to config file in production)
const BITCOIN_API_URL = 'https://api.coindesk.com/v1/bpi/historical/close.json?'; //Example API, replace with your preferred source.

//Data Structures for caching and efficiency
let bitcoinDataCache = null;
let emaCache = null;
let rsiCache = null;
let macdCache = null;
let bbCache = null;


//Helper functions for calcu
[2025-05-16T14:28:50.268Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const app = express();
const port = 3000;
const axios = require('axios');

// Configuration (move to config file in production)
const BITCOIN_API_URL = 'https://api.coindesk.com/v1/bpi/historical/close.json?'; //Example API, replace with your preferred source.

//Data Structures for caching and efficiency
let bitcoinDataCache = null;
let emaCache = null;
let rsiCache = null;
let macdCache = null;
let bbCache = null;


//Helper functions for calculations.  These could be moved to a separate file for better organization.
function EMA(series, period) {
    //Simple Exponential Moving Average calculation
    if(series.length < period) return null; //Handle insufficient data
    let ema = series.slice(0, period).reduce((a, b) => a + b, 0) / period;
    for (let i = period; i < series.length; i++) {
        ema = (series[i] - ema) * (2 / (period + 1)) + ema;
    }
    return ema;
}

function RSI(series, period) {
  //Relative Strength Index calculation
  if(series.length < period) return null; //Handle insufficient data
    let gains = [], losses = [];
    for (let i = 1; i < series.length; i++) {
        let diff = series[i] - series[i - 1];
        if (diff >= 0) gains.push(diff);
        else losses.push(Math.abs(diff));
    }

    let avgGain = gains.slice(0,period).reduce((a,b)=> a+b,0)/period;
    let avgLoss = losses.slice(0,period).reduce((a,b)=> a+b,0)/period;

    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    }

    let rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}


function MACD(series, fastPeriod, slowPeriod, signalPeriod){
    //Moving Average Convergence Divergence calculation
    if(series.length < slowPeriod) return null; //Handle insufficient data
    let fastEMA = EMA(series, fastPeriod);
    let slowEMA = EMA(series, slowPeriod);
    let macdLine = fastEMA - slowEMA;

    let signalLine = EMA(macdLine,signalPeriod);
    return {macdLine, signalLine};

}

function BollingerBands(series, period, stdDev){
    //Bollinger Bands calculation
    if(series.length < period) return null; //Handle insufficient data
    let mean = series.slice(-period).reduce((a,b)=> a+b,0)/period;
    let variance = series.slice(-period).map(x => Math.pow(x-mean,2)).reduce((a,b)=>a+b,0)/period;
    let std = Math.sqrt(variance);
    let upperBand = mean + stdDev * std;
    let lowerBand = mean - stdDev * std;
    return {upperBand, lowerBand, mean};
}

app.get('/bitcoin/price', async (req, res) => {
    try {
        if(bitcoinDataCache){
          res.json(bitcoinDataCache);
          return;
        }
        const response = await axios.get(BITCOIN_API_URL);
        const data = response.data.bpi;
        const timeSeries = Object.values(data).map(item => item.close);
        bitcoinDataCache = {timeSeries}; //Store the data for later use.
        res.json(bitcoinDataCache);

    } catch (error) {
        console.error("Error fetching Bitcoin price:", error);
        res.status(500).json({ error: 'Failed to fetch Bitcoin price' });
    }
});

app.get('/bitcoin/indicators', async (req, res) => {
    const { period, fastPeriod, slowPeriod, signalPeriod, stdDev } = req.query;
    //Add validation for query parameters here

    if(bitcoinDataCache === null){
      res.status(400).send("Bitcoin Price data not fetched yet. Call /bitcoin/price first");
      return;
    }

    const timeSeries = bitcoinDataCache.timeSeries;
    let indicators = {};
    indicators.ema = EMA(timeSeries, parseInt(period));
    indicators.rsi = RSI(timeSeries, parseInt(period));
    indicators.macd = MACD(timeSeries, parseInt(fastPeriod),parseInt(slowPeriod),parseInt(signalPeriod));
    indicators.bb = BollingerBands(timeSeries, parseInt(period), parseFloat(stdDev));


    res.json(indicators);
});



app.listen(port, () => {
    console.log(`Server listening on port ${port}`);
});
```
[2025-05-16T14:28:50.269Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const app = express();
const port = 3000;
const axios = require('axios');

// Configuration (move to config file in production)
const BITCOIN_API_URL = 'https://api.coindesk.com/v1/bpi/historical/close.json?'; //Example API, replace with your preferred source.

//Data Structures for caching and efficiency
let bitcoinDataCache = null;
let emaCache = null;
let rsiCache = null;
let macdCache = null;
let bbCache = null;


//Helper functions for calculations.  These could be moved to a separate file for better organization.
function EMA(series, period) {
    //Simple Exponential Moving Average calculation
    if(series.length < period) return null; //Handle insufficient data
    let ema = series.slice(0, period).reduce((a, b) => a + b, 0) / period;
    for (let i = period; i < series.length; i++) {
        ema = (series[i] - ema) * (2 / (period + 1)) + ema;
    }
    return ema;
}

function RSI(series, period) {
  //Relative Strength Index calculation
  if(series.length < period) return null; //Handle insufficient data
    let gains = [], losses = [];
    for (let i = 1; i < series.length; i++) {
        let diff = series[i] - series[i - 1];
        if (diff >= 0) gains.push(diff);
        else losses.push(Math.abs(diff));
    }

    let avgGain = gains.slice(0,period).reduce((a,b)=> a+b,0)/period;
    let avgLoss = losses.slice(0,period).reduce((a,b)=> a+b,0)/period;

    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    }

    let rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}


function MACD(series, fastPeriod, slowPeriod, signalPeriod){
    //Moving Average Convergence Divergence calculation
    if(series.length < slowPeriod) return null; //Handle insufficient data
    let fastEMA = EMA(series, fastPeriod);
    let slowEMA = EMA(series, slowPeriod);
    let macdLine = fastEMA - slowEMA;

    let signalLine = EMA(macdLine,signalPeriod);
    return {macdLine, signalLine};

}

function BollingerBands(series, period, stdDev){
    //Bollinger Bands calculation
    if(series.length < period) return null; //Handle insufficient data
    let mean = series.slice(-period).reduce((a,b)=> a+b,0)/period;
    let variance = series.slice(-period).map(x => Math.pow(x-mean,2)).reduce((a,b)=>a+b,0)/period;
    let std = Math.sqrt(variance);
    let upperBand = mean + stdDev * std;
    let lowerBand = mean - stdDev * std;
    return {upperBand, lowerBand, mean};
}

app.get('/bitcoin/price', async (req, res) => {
    try {
        if(bitcoinDataCache){
          res.json(bitcoinDataCache);
          return;
        }
        const response = await axios.get(BITCOIN_API_URL);
        const data = response.data.bpi;
        const timeSeries = Object.values(data).map(item => item.close);
        bitcoinDataCache = {timeSeries}; //Store the data for later use.
        res.json(bitcoinDataCache);

    } catch (error) {
        console.error("Error fetching Bitcoin price:", error);
        res.status(500).json({ error: 'Failed to fetch Bitcoin price' });
    }
});

app.get('/bitcoin/indicators', async (req, res) => {
    const { period, fastPeriod, slowPeriod, signalPeriod, stdDev } = req.query;
    //Add validation for query parameters here

    if(bitcoinDataCache === null){
      res.status(400).send("Bitcoin Price data not fetched yet. Call /bitcoin/price first");
      return;
    }

    const timeSeries = bitcoinDataCache.timeSeries;
    let indicators = {};
    indicators.ema = EMA(timeSeries, parseInt(period));
    indicators.rsi = RSI(timeSeries, parseInt(period));
    indicators.macd = MACD(timeSeries, parseInt(fastPeriod),parseInt(slowPeriod),parseInt(signalPeriod));
    indicators.bb = BollingerBands(timeSeries, parseInt(period), parseFloat(stdDev));


    res.json(indicators);
});



app.listen(port, () => {
    console.log(`Server listening on port ${port}`);
});
[2025-05-16T14:28:50.270Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:28:50.271Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:28:50.277Z] INFO: ‚úÖ Saved: routes/Generated_2_api_implement_technical_indicator_calcul.js
[2025-05-16T14:28:55.546Z] INFO: üîÅ [API - Implement Buy/Sell Signal Generation] Attempt 1 of 3
[2025-05-16T14:28:55.636Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Create a rule engine that analyzes the calculated technical indicators to generate buy and sell signals based on the specified conditions.  Generate 'Strong Buy' and 'Strong Sell' signals based on at least 3 out of 5 indicator conditions being met.

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:03.042Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader'); // Local file system
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader'); // GitHub

app.use(express.json());

// Sample technical indicators (replace with your actual data source)
let technicalIndicators = {
  RSI: 70,
  MACD: 20,
  SMA50: 100,
  SMA200: 90,
  Volume: 10000,
};

// Rule Engine
function gener
[2025-05-16T14:29:03.044Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader'); // Local file system
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader'); // GitHub

app.use(express.json());

// Sample technical indicators (replace with your actual data source)
let technicalIndicators = {
  RSI: 70,
  MACD: 20,
  SMA50: 100,
  SMA200: 90,
  Volume: 10000,
};

// Rule Engine
function generateSignal(indicators) {
  let conditionsMet = 0;
  const conditions = [
    indicators.RSI > 70, // Overbought
    indicators.MACD > 0,  // Bullish
    indicators.SMA50 > indicators.SMA200, // Golden Cross
    indicators.Volume > 5000, // High Volume
    indicators.RSI < 30, // Oversold (Sell signal condition)

  ];

  conditions.forEach(condition => {
    if (condition) conditionsMet++;
  });

  if (conditionsMet >= 3) {
    return conditions.includes(indicators.RSI <30) ? 'Strong Sell' : 'Strong Buy';
  }
  return 'Neutral';
}


app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadContextFor(component); // local file system
    res.send(context);

  } catch (err) {
    console.error("Error loading local context:", err);
    res.status(500).send('Error loading context');
  }
});


app.get('/github/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadGitHubContext(component);
    res.send(context);
  } catch (error) {
    console.error("Error loading GitHub context:", error);
    res.status(500).send('Error loading GitHub context');
  }
});


app.post('/signal', (req, res) => {
  try {
    // Validate request body (add more robust validation as needed)
    if (!req.body || !req.body.indicators) {
      return res.status(400).json({ error: 'Missing indicators in request body' });
    }

    const signal = generateSignal(req.body.indicators);
    res.json({ signal });
  } catch (error) {
    console.error("Error generating signal:", error);
    res.status(500).json({ error: 'Failed to generate signal' });
  }
});

app.put('/indicators', (req, res) => {
  try {
    // Validate request body (add more robust validation as needed)
    if (!req.body || Object.keys(req.body).length === 0) {
      return res.status(400).json({ error: 'No indicators provided' });
    }
    technicalIndicators = { ...technicalIndicators, ...req.body };
    res.json({ message: 'Indicators updated successfully', indicators: technicalIndicators });
  } catch (error) {
    console.error("Error updating indicators:", error);
    res.status(500).json({ error: 'Failed to update indicators' });
  }
});

app.get('/indicators', (req, res) => {
    res.json(technicalIndicators);
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```
[2025-05-16T14:29:03.045Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader'); // Local file system
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader'); // GitHub

app.use(express.json());

// Sample technical indicators (replace with your actual data source)
let technicalIndicators = {
  RSI: 70,
  MACD: 20,
  SMA50: 100,
  SMA200: 90,
  Volume: 10000,
};

// Rule Engine
function generateSignal(indicators) {
  let conditionsMet = 0;
  const conditions = [
    indicators.RSI > 70, // Overbought
    indicators.MACD > 0,  // Bullish
    indicators.SMA50 > indicators.SMA200, // Golden Cross
    indicators.Volume > 5000, // High Volume
    indicators.RSI < 30, // Oversold (Sell signal condition)

  ];

  conditions.forEach(condition => {
    if (condition) conditionsMet++;
  });

  if (conditionsMet >= 3) {
    return conditions.includes(indicators.RSI <30) ? 'Strong Sell' : 'Strong Buy';
  }
  return 'Neutral';
}


app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadContextFor(component); // local file system
    res.send(context);

  } catch (err) {
    console.error("Error loading local context:", err);
    res.status(500).send('Error loading context');
  }
});


app.get('/github/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadGitHubContext(component);
    res.send(context);
  } catch (error) {
    console.error("Error loading GitHub context:", error);
    res.status(500).send('Error loading GitHub context');
  }
});


app.post('/signal', (req, res) => {
  try {
    // Validate request body (add more robust validation as needed)
    if (!req.body || !req.body.indicators) {
      return res.status(400).json({ error: 'Missing indicators in request body' });
    }

    const signal = generateSignal(req.body.indicators);
    res.json({ signal });
  } catch (error) {
    console.error("Error generating signal:", error);
    res.status(500).json({ error: 'Failed to generate signal' });
  }
});

app.put('/indicators', (req, res) => {
  try {
    // Validate request body (add more robust validation as needed)
    if (!req.body || Object.keys(req.body).length === 0) {
      return res.status(400).json({ error: 'No indicators provided' });
    }
    technicalIndicators = { ...technicalIndicators, ...req.body };
    res.json({ message: 'Indicators updated successfully', indicators: technicalIndicators });
  } catch (error) {
    console.error("Error updating indicators:", error);
    res.status(500).json({ error: 'Failed to update indicators' });
  }
});

app.get('/indicators', (req, res) => {
    res.json(technicalIndicators);
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});
[2025-05-16T14:29:03.046Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:03.046Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:03.047Z] WARN: ‚ö†Ô∏è [API - Implement Buy/Sell Signal Generation] Failed on attempt 1: Syntax error in generated code
[2025-05-16T14:29:03.550Z] INFO: üîÅ [API - Implement Buy/Sell Signal Generation] Attempt 2 of 3
[2025-05-16T14:29:03.637Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Create a rule engine that analyzes the calculated technical indicators to generate buy and sell signals based on the specified conditions.  Generate 'Strong Buy' and 'Strong Sell' signals based on at least 3 out of 5 indicator conditions being met.

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:09.109Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader'); // For local context
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader'); // For GitHub context


app.use(express.json());

// Sample technical indicator data (replace with your actual data source)
let technicalIndicators = {
  RSI: 70,
  MACD: 20,
  SMA: 150,
  EMA: 160,
  Volume: 10000,
};

// Function to g
[2025-05-16T14:29:09.110Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader'); // For local context
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader'); // For GitHub context


app.use(express.json());

// Sample technical indicator data (replace with your actual data source)
let technicalIndicators = {
  RSI: 70,
  MACD: 20,
  SMA: 150,
  EMA: 160,
  Volume: 10000,
};

// Function to generate buy/sell signals
function generateSignals(indicators) {
  const conditions = [
    indicators.RSI > 70, // Overbought
    indicators.MACD > 0, // Bullish
    indicators.SMA < indicators.EMA, // Bullish crossover
    indicators.Volume > 5000, // High volume
    indicators.RSI < 30, //Oversold (Sell signal)
  ];

  const buyConditions = conditions.slice(0,4);
  const sellConditions = [conditions[4]];

  const buyCount = buyConditions.filter(c => c).length;
  const sellCount = sellConditions.filter(c => c).length;


  let signal = '';
  if (buyCount >= 3) {
    signal = 'Strong Buy';
  } else if (sellCount >=1 && buyCount < 3){
    signal = 'Strong Sell';
  } else {
    signal = 'Neutral';
  }
  return signal;
}


// API endpoint to get buy/sell signals
app.get('/signals', async (req, res) => {
  try {
    const signal = generateSignals(technicalIndicators);
    res.json({ signal });
  } catch (error) {
    console.error('Error generating signals:', error);
    res.status(500).json({ error: 'Failed to generate signals' });
  }
});


// API endpoint to update technical indicators (POST)
app.post('/indicators', (req, res) => {
    // Input validation
    const { RSI, MACD, SMA, EMA, Volume } = req.body;
    if (!RSI || !MACD || !SMA || !EMA || !Volume) {
      return res.status(400).json({ error: 'Missing required indicators' });
    }
    technicalIndicators = { RSI, MACD, SMA, EMA, Volume };
    res.json({ message: 'Indicators updated successfully' });
});


//Load Context from local file system or GitHub
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const localContext = loadContextFor(component);
    const gitHubContext = await loadGitHubContext(component);

    res.json({localContext, gitHubContext});

  } catch (err) {
    console.error("Error loading context", err)
    res.status(500).json({ error: 'Failed to load context' });
  }
})

app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```
[2025-05-16T14:29:09.110Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader'); // For local context
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader'); // For GitHub context


app.use(express.json());

// Sample technical indicator data (replace with your actual data source)
let technicalIndicators = {
  RSI: 70,
  MACD: 20,
  SMA: 150,
  EMA: 160,
  Volume: 10000,
};

// Function to generate buy/sell signals
function generateSignals(indicators) {
  const conditions = [
    indicators.RSI > 70, // Overbought
    indicators.MACD > 0, // Bullish
    indicators.SMA < indicators.EMA, // Bullish crossover
    indicators.Volume > 5000, // High volume
    indicators.RSI < 30, //Oversold (Sell signal)
  ];

  const buyConditions = conditions.slice(0,4);
  const sellConditions = [conditions[4]];

  const buyCount = buyConditions.filter(c => c).length;
  const sellCount = sellConditions.filter(c => c).length;


  let signal = '';
  if (buyCount >= 3) {
    signal = 'Strong Buy';
  } else if (sellCount >=1 && buyCount < 3){
    signal = 'Strong Sell';
  } else {
    signal = 'Neutral';
  }
  return signal;
}


// API endpoint to get buy/sell signals
app.get('/signals', async (req, res) => {
  try {
    const signal = generateSignals(technicalIndicators);
    res.json({ signal });
  } catch (error) {
    console.error('Error generating signals:', error);
    res.status(500).json({ error: 'Failed to generate signals' });
  }
});


// API endpoint to update technical indicators (POST)
app.post('/indicators', (req, res) => {
    // Input validation
    const { RSI, MACD, SMA, EMA, Volume } = req.body;
    if (!RSI || !MACD || !SMA || !EMA || !Volume) {
      return res.status(400).json({ error: 'Missing required indicators' });
    }
    technicalIndicators = { RSI, MACD, SMA, EMA, Volume };
    res.json({ message: 'Indicators updated successfully' });
});


//Load Context from local file system or GitHub
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const localContext = loadContextFor(component);
    const gitHubContext = await loadGitHubContext(component);

    res.json({localContext, gitHubContext});

  } catch (err) {
    console.error("Error loading context", err)
    res.status(500).json({ error: 'Failed to load context' });
  }
})

app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});
[2025-05-16T14:29:09.111Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:09.111Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:09.112Z] INFO: ‚úÖ Saved: routes/Generated_3_api_implement_buy_sell_signal_generation.js
[2025-05-16T14:29:14.226Z] INFO: üîÅ [API - Implement Email Notification System] Attempt 1 of 3
[2025-05-16T14:29:14.307Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Integrate a Nodemailer (or similar) function to send email notifications to kesarwanimohit@yahoo.com upon generation of a 'Strong Buy' or 'Strong Sell' signal.  The email should include signal type, timestamp (AEST), current price, and a summary of triggering indicators. Implement rate limiting to prevent excessive notifications (default 4 hours).

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:20.945Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader');
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader');
const nodemailer = require('nodemailer');
const rateLimit = require('express-rate-limit');

require('dotenv').config();

// Email configuration
const transporter = nodemailer.createTransport({
  service: 'gmail', // Or your preferred email service
  auth: {
[2025-05-16T14:29:20.946Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader');
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader');
const nodemailer = require('nodemailer');
const rateLimit = require('express-rate-limit');

require('dotenv').config();

// Email configuration
const transporter = nodemailer.createTransport({
  service: 'gmail', // Or your preferred email service
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

// Rate limiting middleware (4 hours)
const limiter = rateLimit({
  windowMs: 4 * 60 * 60 * 1000, // 4 hours
  max: 1, // Limit each IP to 1 request per windowMs
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
});

// API routes
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadContextFor(component);
    res.send(context);
  } catch (error) {
    console.error("Error fetching local context:", error);
    res.status(500).send('Error fetching context');
  }
});


app.get('/github/:component', limiter, async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadGitHubContext(component);
    res.send(context);
  } catch (error) {
    console.error("Error fetching GitHub context:", error);
    res.status(500).send('Error fetching GitHub context');
  }
});


app.post('/signal', async (req, res) => {
  const { signalType, currentPrice, indicators } = req.body;

  //Basic validation.  More robust validation should be added in a production environment.
  if (!signalType || !currentPrice || !indicators) {
    return res.status(400).json({ error: 'Missing required fields' });
  }


  if (signalType === 'Strong Buy' || signalType === 'Strong Sell') {
    const now = new Date();
    const aest = new Date(now.getTime() + now.getTimezoneOffset() * 60000 + 10 * 60 * 60 * 1000); //Convert to AEST
    const formattedDate = aest.toLocaleString('en-AU', { timeZone: 'Australia/Sydney' });

    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: 'kesarwanimohit@yahoo.com',
      subject: `Trading Signal: ${signalType}`,
      text: `
        Signal Type: ${signalType}
        Timestamp (AEST): ${formattedDate}
        Current Price: ${currentPrice}
        Indicators: ${indicators}
      `,
    };

    try {
      await transporter.sendMail(mailOptions);
      console.log('Email sent successfully!');
      res.status(200).json({ message: 'Signal received and email sent' });
    } catch (error) {
      console.error('Error sending email:', error);
      res.status(500).json({ error: 'Failed to send email' });
    }
  } else {
    res.status(200).json({ message: 'Signal received' }); //No email for other signal types.
  }
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```
[2025-05-16T14:29:20.948Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const app = express();
const port = 3000;
const { loadContextFor } = require('./context/contextLoader');
const { loadContextFor: loadGitHubContext } = require('./context/githubContextLoader');
const nodemailer = require('nodemailer');
const rateLimit = require('express-rate-limit');

require('dotenv').config();

// Email configuration
const transporter = nodemailer.createTransport({
  service: 'gmail', // Or your preferred email service
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

// Rate limiting middleware (4 hours)
const limiter = rateLimit({
  windowMs: 4 * 60 * 60 * 1000, // 4 hours
  max: 1, // Limit each IP to 1 request per windowMs
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
});

// API routes
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadContextFor(component);
    res.send(context);
  } catch (error) {
    console.error("Error fetching local context:", error);
    res.status(500).send('Error fetching context');
  }
});


app.get('/github/:component', limiter, async (req, res) => {
  const component = req.params.component;
  try {
    const context = await loadGitHubContext(component);
    res.send(context);
  } catch (error) {
    console.error("Error fetching GitHub context:", error);
    res.status(500).send('Error fetching GitHub context');
  }
});


app.post('/signal', async (req, res) => {
  const { signalType, currentPrice, indicators } = req.body;

  //Basic validation.  More robust validation should be added in a production environment.
  if (!signalType || !currentPrice || !indicators) {
    return res.status(400).json({ error: 'Missing required fields' });
  }


  if (signalType === 'Strong Buy' || signalType === 'Strong Sell') {
    const now = new Date();
    const aest = new Date(now.getTime() + now.getTimezoneOffset() * 60000 + 10 * 60 * 60 * 1000); //Convert to AEST
    const formattedDate = aest.toLocaleString('en-AU', { timeZone: 'Australia/Sydney' });

    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: 'kesarwanimohit@yahoo.com',
      subject: `Trading Signal: ${signalType}`,
      text: `
        Signal Type: ${signalType}
        Timestamp (AEST): ${formattedDate}
        Current Price: ${currentPrice}
        Indicators: ${indicators}
      `,
    };

    try {
      await transporter.sendMail(mailOptions);
      console.log('Email sent successfully!');
      res.status(200).json({ message: 'Signal received and email sent' });
    } catch (error) {
      console.error('Error sending email:', error);
      res.status(500).json({ error: 'Failed to send email' });
    }
  } else {
    res.status(200).json({ message: 'Signal received' }); //No email for other signal types.
  }
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});
[2025-05-16T14:29:20.949Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:20.949Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:20.953Z] INFO: ‚úÖ Saved: routes/Generated_4_api_implement_email_notification_system.js
[2025-05-16T14:29:25.898Z] INFO: üîÅ [API - Implement Logging Functionality] Attempt 1 of 3
[2025-05-16T14:29:25.988Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Create a logging system (e.g., using Winston or a similar logger) to record all fetched data points, generated signals (including non-'Strong' signals), and sent email notifications, including timestamps.

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:31.015Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const app = express();
const port = 3000;
const winston = require('winston');
const { combine, timestamp, label, printf } = winston.format;
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Configure Winston logger
const myFormat = printf(({ level, message, label, timestamp }) => {
  return `${timestamp} [${label}] ${level}: ${message}`;
});

const logger = winston.
[2025-05-16T14:29:31.017Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const app = express();
const port = 3000;
const winston = require('winston');
const { combine, timestamp, label, printf } = winston.format;
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Configure Winston logger
const myFormat = printf(({ level, message, label, timestamp }) => {
  return `${timestamp} [${label}] ${level}: ${message}`;
});

const logger = winston.createLogger({
  level: 'info',
  format: combine(
    label({ label: 'App' }),
    timestamp(),
    myFormat
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'combined.log' })
  ],
  exceptionHandlers: [
    new winston.transports.File({ filename: 'exceptions.log' })
  ]
});


app.use(express.json());

// API routes
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  logger.info(`Fetching context for component: ${component}`);
  try {
    let context;
    if (process.env.GITHUB_TOKEN) {
      context = await githubContextLoader.loadContextFor(component);
      logger.info(`GitHub context loaded successfully for component: ${component}`);
    } else {
      context = contextLoader.loadContextFor(component);
      logger.info(`Local context loaded successfully for component: ${component}`);
    }

    res.json({ context });
  } catch (error) {
    logger.error(`Error fetching context for ${component}: ${error.message}`);
    res.status(500).json({ error: 'Failed to fetch context' });
  }
});


// Error handling middleware
app.use((err, req, res, next) => {
  logger.error(`Unhandled error: ${err.message}`);
  res.status(500).json({ error: 'Internal server error' });
});


// Start the server
app.listen(port, () => {
  logger.info(`Server listening on port ${port}`);
});

```
[2025-05-16T14:29:31.018Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const app = express();
const port = 3000;
const winston = require('winston');
const { combine, timestamp, label, printf } = winston.format;
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Configure Winston logger
const myFormat = printf(({ level, message, label, timestamp }) => {
  return `${timestamp} [${label}] ${level}: ${message}`;
});

const logger = winston.createLogger({
  level: 'info',
  format: combine(
    label({ label: 'App' }),
    timestamp(),
    myFormat
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'combined.log' })
  ],
  exceptionHandlers: [
    new winston.transports.File({ filename: 'exceptions.log' })
  ]
});


app.use(express.json());

// API routes
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  logger.info(`Fetching context for component: ${component}`);
  try {
    let context;
    if (process.env.GITHUB_TOKEN) {
      context = await githubContextLoader.loadContextFor(component);
      logger.info(`GitHub context loaded successfully for component: ${component}`);
    } else {
      context = contextLoader.loadContextFor(component);
      logger.info(`Local context loaded successfully for component: ${component}`);
    }

    res.json({ context });
  } catch (error) {
    logger.error(`Error fetching context for ${component}: ${error.message}`);
    res.status(500).json({ error: 'Failed to fetch context' });
  }
});


// Error handling middleware
app.use((err, req, res, next) => {
  logger.error(`Unhandled error: ${err.message}`);
  res.status(500).json({ error: 'Internal server error' });
});


// Start the server
app.listen(port, () => {
  logger.info(`Server listening on port ${port}`);
});
[2025-05-16T14:29:31.020Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:31.020Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:31.024Z] INFO: ‚úÖ Saved: routes/Generated_5_api_implement_logging_functionality.js
[2025-05-16T14:29:36.433Z] INFO: üîÅ [API - Implement Configuration Management] Attempt 1 of 3
[2025-05-16T14:29:36.525Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Implement a mechanism to manage configurable parameters (API fetch interval, email notification frequency, technical indicator parameters) either through environment variables or a configuration file.

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:41.577Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;
const fs = require('node:fs');
const path = require('node:path');
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Configuration loading - prioritized order: environment variables, then config file
const config = {
  apiFetchInterval: process.env.API_FETCH_INTERVAL || 60000, // Default to 60 seconds
  em
[2025-05-16T14:29:41.578Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;
const fs = require('node:fs');
const path = require('node:path');
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Configuration loading - prioritized order: environment variables, then config file
const config = {
  apiFetchInterval: process.env.API_FETCH_INTERVAL || 60000, // Default to 60 seconds
  emailNotificationFrequency: process.env.EMAIL_NOTIFICATION_FREQUENCY || 'daily', // Default to 'daily'
  technicalIndicatorParams: JSON.parse(process.env.TECHNICAL_INDICATOR_PARAMS || '{}'), // Default to empty object
};

try {
  const configFile = fs.readFileSync(path.join(__dirname, 'config.json'), 'utf8');
  const fileConfig = JSON.parse(configFile);
  Object.assign(config, fileConfig); // Override with config file values
} catch (err) {
  console.warn('‚ö†Ô∏è Configuration file not found or invalid. Using defaults or environment variables.');
}


app.use(express.json());

//Example endpoint to demonstrate configuration access
app.get('/config', (req, res) => {
    res.json(config);
});

app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const localContext = contextLoader.loadContextFor(component);
    if(localContext){
        res.send(localContext);
        return;
    }
    const githubContext = await githubContextLoader.loadContextFor(component);
    res.send(githubContext);

  } catch (error) {
    console.error('Error fetching context:', error);
    res.status(500).send('Error fetching context');
  }
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

//Example config.json file
// {
//   "apiFetchInterval": 120000,
//   "emailNotificationFrequency": "hourly",
//   "technicalIndicatorParams": {
//     "rsiPeriod": 14,
//     "maPeriod": 20
//   }
// }

```
[2025-05-16T14:29:41.578Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;
const fs = require('node:fs');
const path = require('node:path');
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Configuration loading - prioritized order: environment variables, then config file
const config = {
  apiFetchInterval: process.env.API_FETCH_INTERVAL || 60000, // Default to 60 seconds
  emailNotificationFrequency: process.env.EMAIL_NOTIFICATION_FREQUENCY || 'daily', // Default to 'daily'
  technicalIndicatorParams: JSON.parse(process.env.TECHNICAL_INDICATOR_PARAMS || '{}'), // Default to empty object
};

try {
  const configFile = fs.readFileSync(path.join(__dirname, 'config.json'), 'utf8');
  const fileConfig = JSON.parse(configFile);
  Object.assign(config, fileConfig); // Override with config file values
} catch (err) {
  console.warn(' Configuration file not found or invalid. Using defaults or environment variables.');
}


app.use(express.json());

//Example endpoint to demonstrate configuration access
app.get('/config', (req, res) => {
    res.json(config);
});

app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const localContext = contextLoader.loadContextFor(component);
    if(localContext){
        res.send(localContext);
        return;
    }
    const githubContext = await githubContextLoader.loadContextFor(component);
    res.send(githubContext);

  } catch (error) {
    console.error('Error fetching context:', error);
    res.status(500).send('Error fetching context');
  }
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

//Example config.json file
// {
//   "apiFetchInterval": 120000,
//   "emailNotificationFrequency": "hourly",
//   "technicalIndicatorParams": {
//     "rsiPeriod": 14,
//     "maPeriod": 20
//   }
// }
[2025-05-16T14:29:41.579Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:41.579Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:41.581Z] INFO: ‚úÖ Saved: routes/Generated_6_api_implement_configuration_management.js
[2025-05-16T14:29:46.622Z] INFO: üîÅ [API - Implement AEST Timezone Conversion] Attempt 1 of 3
[2025-05-16T14:29:46.752Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Ensure that all timestamps in the application and email notifications are correctly converted to Australian Eastern Standard Time (AEST).

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:50.604Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const moment = require('moment-timezone');
const app = express();
const port = 3000;
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Set the timezone to AEST
moment.tz.setDefault('Australia/Sydney');

app.use(express.json());

app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    let context;
    //Prioritize lo
[2025-05-16T14:29:50.606Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const moment = require('moment-timezone');
const app = express();
const port = 3000;
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Set the timezone to AEST
moment.tz.setDefault('Australia/Sydney');

app.use(express.json());

app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    let context;
    //Prioritize local context if available.  Fallback to Github
    try{
        context = contextLoader.loadContextFor(component);
    } catch(error){
        console.warn("Local context loading failed. Falling back to Github", error);
        context = await githubContextLoader.loadContextFor(component);
    }

    const timestamp = moment().format('YYYY-MM-DD HH:mm:ss AEST'); // Format timestamp in AEST
    res.json({ component, context, timestamp });
  } catch (error) {
    console.error('Error fetching context:', error);
    res.status(500).json({ error: 'Failed to fetch context' });
  }
});


// Example error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});


app.listen(port, () => {
  console.log(`Server listening at http://localhost:${port}`);
});

```

[2025-05-16T14:29:50.607Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const moment = require('moment-timezone');
const app = express();
const port = 3000;
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

// Set the timezone to AEST
moment.tz.setDefault('Australia/Sydney');

app.use(express.json());

app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    let context;
    //Prioritize local context if available.  Fallback to Github
    try{
        context = contextLoader.loadContextFor(component);
    } catch(error){
        console.warn("Local context loading failed. Falling back to Github", error);
        context = await githubContextLoader.loadContextFor(component);
    }

    const timestamp = moment().format('YYYY-MM-DD HH:mm:ss AEST'); // Format timestamp in AEST
    res.json({ component, context, timestamp });
  } catch (error) {
    console.error('Error fetching context:', error);
    res.status(500).json({ error: 'Failed to fetch context' });
  }
});


// Example error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});


app.listen(port, () => {
  console.log(`Server listening at http://localhost:${port}`);
});

```
[2025-05-16T14:29:50.607Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:50.608Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:50.609Z] WARN: ‚ö†Ô∏è [API - Implement AEST Timezone Conversion] Failed on attempt 1: Syntax error in generated code
[2025-05-16T14:29:51.110Z] INFO: üîÅ [API - Implement AEST Timezone Conversion] Attempt 2 of 3
[2025-05-16T14:29:51.196Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Ensure that all timestamps in the application and email notifications are correctly converted to Australian Eastern Standard Time (AEST).

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:54.224Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const moment = require('moment-timezone');
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

const app = express();
const port = 3000;

app.use(express.json());

// Set the timezone to AEST
moment.tz.setDefault('Australia/Sydney');

// Route to load context from local filesystem
app.get('/context/:component', (req, res) => {
  const component = req.params.component;
  
[2025-05-16T14:29:54.225Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const moment = require('moment-timezone');
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

const app = express();
const port = 3000;

app.use(express.json());

// Set the timezone to AEST
moment.tz.setDefault('Australia/Sydney');

// Route to load context from local filesystem
app.get('/context/:component', (req, res) => {
  const component = req.params.component;
  const context = contextLoader.loadContextFor(component);
  res.json({ timestamp: moment().format(), context });
});


// Route to load context from GitHub
app.get('/github/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await githubContextLoader.loadContextFor(component);
    res.json({ timestamp: moment().format(), context });
  } catch (error) {
    console.error("Error fetching GitHub context:", error);
    res.status(500).json({ timestamp: moment().format(), error: 'Failed to fetch GitHub context' });
  }
});


//Error Handling Middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ timestamp: moment().format(), error: 'Internal Server Error' });
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```

[2025-05-16T14:29:54.225Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const moment = require('moment-timezone');
const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

const app = express();
const port = 3000;

app.use(express.json());

// Set the timezone to AEST
moment.tz.setDefault('Australia/Sydney');

// Route to load context from local filesystem
app.get('/context/:component', (req, res) => {
  const component = req.params.component;
  const context = contextLoader.loadContextFor(component);
  res.json({ timestamp: moment().format(), context });
});


// Route to load context from GitHub
app.get('/github/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    const context = await githubContextLoader.loadContextFor(component);
    res.json({ timestamp: moment().format(), context });
  } catch (error) {
    console.error("Error fetching GitHub context:", error);
    res.status(500).json({ timestamp: moment().format(), error: 'Failed to fetch GitHub context' });
  }
});


//Error Handling Middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ timestamp: moment().format(), error: 'Internal Server Error' });
});


app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```
[2025-05-16T14:29:54.226Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:54.227Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:54.228Z] WARN: ‚ö†Ô∏è [API - Implement AEST Timezone Conversion] Failed on attempt 2: Syntax error in generated code
[2025-05-16T14:29:55.230Z] INFO: üîÅ [API - Implement AEST Timezone Conversion] Attempt 3 of 3
[2025-05-16T14:29:55.317Z] INFO: üß† Gemini Prompt Sent:
You are a professional Node.js backend engineer.

--- TASK ---
üíæ GitHub Repository Context (2 files):

// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


---
Task:
Ensure that all timestamps in the application and email notifications are correctly converted to Australian Eastern Standard Time (AEST).

--- RELATED CONTEXT ---


‚úÖ Instructions:
- Use Express.js to implement the API
- Handle routes, errors, and data cleanly
- Use appropriate HTTP verbs
- Add logging, validation, and modular structure
- Avoid duplication if route already exists
- Output clean working code

üì¶ Output Format:
Return only code in one ```javascript block.
[2025-05-16T14:29:58.219Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const express = require('express');
const moment = require('moment-timezone');
const app = express();
const port = 3000;

const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

app.use(express.json());

// Configure moment-timezone for AEST
moment.tz.setDefault('Australia/Sydney');


// API endpoint to load context
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;

[2025-05-16T14:29:58.220Z] INFO: üîß API Agent Output (raw):
```javascript
const express = require('express');
const moment = require('moment-timezone');
const app = express();
const port = 3000;

const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

app.use(express.json());

// Configure moment-timezone for AEST
moment.tz.setDefault('Australia/Sydney');


// API endpoint to load context
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    let context;
    // Prioritize local context if available, fallback to GitHub
    try {
      context = contextLoader.loadContextFor(component);
    } catch (localErr) {
      console.warn("Error loading local context:", localErr);
      context = await githubContextLoader.loadContextFor(component);
    }


    const timestamp = moment().format('YYYY-MM-DD HH:mm:ss AEST'); //AEST timestamp
    res.json({ context, timestamp });
  } catch (error) {
    console.error('Error fetching context:', error);
    res.status(500).json({ error: 'Failed to fetch context' });
  }
});


// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal Server Error' });
});

app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```

[2025-05-16T14:29:58.221Z] INFO: ‚úÖ API Agent Output (cleaned):
const express = require('express');
const moment = require('moment-timezone');
const app = express();
const port = 3000;

const contextLoader = require('./context/contextLoader');
const githubContextLoader = require('./context/githubContextLoader');

app.use(express.json());

// Configure moment-timezone for AEST
moment.tz.setDefault('Australia/Sydney');


// API endpoint to load context
app.get('/context/:component', async (req, res) => {
  const component = req.params.component;
  try {
    let context;
    // Prioritize local context if available, fallback to GitHub
    try {
      context = contextLoader.loadContextFor(component);
    } catch (localErr) {
      console.warn("Error loading local context:", localErr);
      context = await githubContextLoader.loadContextFor(component);
    }


    const timestamp = moment().format('YYYY-MM-DD HH:mm:ss AEST'); //AEST timestamp
    res.json({ context, timestamp });
  } catch (error) {
    console.error('Error fetching context:', error);
    res.status(500).json({ error: 'Failed to fetch context' });
  }
});


// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal Server Error' });
});

app.listen(port, () => {
  console.log(`Server listening on port ${port}`);
});

```
[2025-05-16T14:29:58.222Z] INFO: ‚úÖ render.yaml generated.
[2025-05-16T14:29:58.222Z] WARN: ‚ö†Ô∏è No index.js found to patch with Express server.
[2025-05-16T14:29:58.223Z] WARN: ‚ö†Ô∏è [API - Implement AEST Timezone Conversion] Failed on attempt 3: Syntax error in generated code
[2025-05-16T14:30:00.225Z] ERROR: ‚ùå [API - Implement AEST Timezone Conversion] Failed after 3 retries
[2025-05-16T14:30:00.228Z] ERROR: ‚ùå Backend agent failed permanently: Syntax error in generated code
[2025-05-16T14:30:05.692Z] INFO: üîÅ [TEST - Unit Tests for Price Data Fetching] Attempt 1 of 3
[2025-05-16T14:30:11.017Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the correct fetching and handling of Bitcoin price data from the CoinGecko API, including error handling and rate limiting.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:30:17.574Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the route is here
const axios = require('axios');

jest.mock('axios');

describe('getBitcoinPrice', () => {
  it('should successfully fetch and return Bitcoin price', async () => {
    const mockResponse = {
      data: {
        bitcoin: {
          usd: 30000,
        },
      },
    };
    axios.get.mockResolvedValue(mockResponse);

    const price = await getBitcoinPrice();
    expect(price).toBe(3000
[2025-05-16T14:30:17.575Z] INFO: üß™ Raw test output:
```javascript
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the route is here
const axios = require('axios');

jest.mock('axios');

describe('getBitcoinPrice', () => {
  it('should successfully fetch and return Bitcoin price', async () => {
    const mockResponse = {
      data: {
        bitcoin: {
          usd: 30000,
        },
      },
    };
    axios.get.mockResolvedValue(mockResponse);

    const price = await getBitcoinPrice();
    expect(price).toBe(30000);
    expect(axios.get).toHaveBeenCalledTimes(1);
    expect(axios.get).toHaveBeenCalledWith(
      expect.stringContaining('https://api.coingecko.com/api/v3/simple/price')
    );
  });

  it('should handle API error gracefully', async () => {
    const mockError = new Error('Request failed with status code 404');
    axios.get.mockRejectedValue(mockError);

    try {
      await getBitcoinPrice();
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toEqual(expect.stringContaining('failed'));
      expect(axios.get).toHaveBeenCalledTimes(1);
    }
  });


  it('should handle rate limiting', async () => {
    const mockRateLimitError = { response: { status: 429 } };
    axios.get.mockRejectedValue(mockRateLimitError);

    try {
      await getBitcoinPrice();
      //This should not be reached as an error is expected from the mock.
      expect(true).toBe(false);
    } catch (error) {
      expect(error).toBeDefined();
      expect(axios.get).toHaveBeenCalledTimes(1);

    }
  });

  it('should handle invalid JSON response', async () => {
    axios.get.mockResolvedValue({ data: 'invalid json' });
    await expect(getBitcoinPrice()).rejects.toThrow();
    expect(axios.get).toHaveBeenCalledTimes(1);

  });

  it('should handle missing price data', async () => {
    axios.get.mockResolvedValue({ data: { bitcoin: {} } });
    await expect(getBitcoinPrice()).rejects.toThrow();
    expect(axios.get).toHaveBeenCalledTimes(1);
  });

  it('should handle non-numeric price data', async () => {
    axios.get.mockResolvedValue({ data: { bitcoin: { usd: 'not a number' } } });
    await expect(getBitcoinPrice()).rejects.toThrow();
    expect(axios.get).toHaveBeenCalledTimes(1);
  });

  it('should handle network error', async () => {
    axios.get.mockRejectedValue(new Error('Network error'));
    await expect(getBitcoinPrice()).rejects.toThrow('Network error');
    expect(axios.get).toHaveBeenCalledTimes(1);
  });


});

```

[2025-05-16T14:30:17.577Z] INFO: ‚úÖ Cleaned test output:
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the route is hereconst axios = require('axios');jest.mock('axios');describe('getBitcoinPrice', () => {  it('should successfully fetch and return Bitcoin price', async () => {    const mockResponse = {      data: {        bitcoin: {          usd: 30000,        },      },    };    axios.get.mockResolvedValue(mockResponse);    const price = await getBitcoinPrice();    expect(price).toBe(30000);    expect(axios.get).toHaveBeenCalledTimes(1);    expect(axios.get).toHaveBeenCalledWith(      expect.stringContaining('https://api.coingecko.com/api/v3/simple/price')    );  });  it('should handle API error gracefully', async () => {    const mockError = new Error('Request failed with status code 404');    axios.get.mockRejectedValue(mockError);    try {      await getBitcoinPrice();    } catch (error) {      expect(error).toBeDefined();      expect(error.message).toEqual(expect.stringContaining('failed'));      expect(axios.get).toHaveBeenCalledTimes(1);    }  });  it('should handle rate limiting', async () => {    const mockRateLimitError = { response: { status: 429 } };    axios.get.mockRejectedValue(mockRateLimitError);    try {      await getBitcoinPrice();      //This should not be reached as an error is expected from the mock.      expect(true).toBe(false);    } catch (error) {      expect(error).toBeDefined();      expect(axios.get).toHaveBeenCalledTimes(1);    }  });  it('should handle invalid JSON response', async () => {    axios.get.mockResolvedValue({ data: 'invalid json' });    await expect(getBitcoinPrice()).rejects.toThrow();    expect(axios.get).toHaveBeenCalledTimes(1);  });  it('should handle missing price data', async () => {    axios.get.mockResolvedValue({ data: { bitcoin: {} } });    await expect(getBitcoinPrice()).rejects.toThrow();    expect(axios.get).toHaveBeenCalledTimes(1);  });  it('should handle non-numeric price data', async () => {    axios.get.mockResolvedValue({ data: { bitcoin: { usd: 'not a number' } } });    await expect(getBitcoinPrice()).rejects.toThrow();    expect(axios.get).toHaveBeenCalledTimes(1);  });  it('should handle network error', async () => {    axios.get.mockRejectedValue(new Error('Network error'));    await expect(getBitcoinPrice()).rejects.toThrow('Network error');    expect(axios.get).toHaveBeenCalledTimes(1);  });});```
[2025-05-16T14:30:17.577Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:30:17.578Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:30:17.578Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Price Data Fetching] Failed on attempt 1: Test generation failed
[2025-05-16T14:30:18.079Z] INFO: üîÅ [TEST - Unit Tests for Price Data Fetching] Attempt 2 of 3
[2025-05-16T14:30:23.459Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the correct fetching and handling of Bitcoin price data from the CoinGecko API, including error handling and rate limiting.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:30:29.186Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the implementation is here
const axios = require('axios');

jest.mock('axios');

describe('getBitcoinPrice', () => {
  it('should successfully fetch and return Bitcoin price', async () => {
    const mockResponse = {
      data: {
        bitcoin: {
          usd: 30000,
        },
      },
    };
    axios.get.mockResolvedValue(mockResponse);

    const price = await getBitcoinPrice();
    expect(price).
[2025-05-16T14:30:29.187Z] INFO: üß™ Raw test output:
```javascript
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the implementation is here
const axios = require('axios');

jest.mock('axios');

describe('getBitcoinPrice', () => {
  it('should successfully fetch and return Bitcoin price', async () => {
    const mockResponse = {
      data: {
        bitcoin: {
          usd: 30000,
        },
      },
    };
    axios.get.mockResolvedValue(mockResponse);

    const price = await getBitcoinPrice();
    expect(price).toBe(30000);
    expect(axios.get).toHaveBeenCalledWith('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd'); // Replace with your actual API endpoint
  });

  it('should handle API errors gracefully', async () => {
    const mockError = new Error('Request failed with status code 404');
    axios.get.mockRejectedValue(mockError);

    await expect(getBitcoinPrice()).rejects.toThrow('Failed to fetch Bitcoin price');
    expect(axios.get).toHaveBeenCalledTimes(1);
  });


  it('should handle rate limiting', async () => {
    const mockRateLimitError = { response: { status: 429 } }; // Example rate limit status code
    axios.get.mockRejectedValue(mockRateLimitError);

    await expect(getBitcoinPrice()).rejects.toThrow('Rate limit exceeded'); // Or a more specific error message
    expect(axios.get).toHaveBeenCalledTimes(1);
  });


  it('should handle invalid API response', async () => {
    const mockInvalidResponse = { data: {} };
    axios.get.mockResolvedValue(mockInvalidResponse);
    await expect(getBitcoinPrice()).rejects.toThrow('Invalid API response');
  });

  it('should handle missing Bitcoin data in response', async () => {
    const mockMissingData = { data: { bitcoin: {} }};
    axios.get.mockResolvedValue(mockMissingData);
    await expect(getBitcoinPrice()).rejects.toThrow('Missing Bitcoin price data in API response');
  });

  it('should handle non-numeric Bitcoin price', async () => {
    const mockNonNumericPrice = { data: { bitcoin: { usd: 'abc' } } };
    axios.get.mockResolvedValue(mockNonNumericPrice);
    await expect(getBitcoinPrice()).rejects.toThrow('Invalid Bitcoin price format');
  });

});
```

[2025-05-16T14:30:29.188Z] INFO: ‚úÖ Cleaned test output:
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the implementation is hereconst axios = require('axios');jest.mock('axios');describe('getBitcoinPrice', () => {  it('should successfully fetch and return Bitcoin price', async () => {    const mockResponse = {      data: {        bitcoin: {          usd: 30000,        },      },    };    axios.get.mockResolvedValue(mockResponse);    const price = await getBitcoinPrice();    expect(price).toBe(30000);    expect(axios.get).toHaveBeenCalledWith('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd'); // Replace with your actual API endpoint  });  it('should handle API errors gracefully', async () => {    const mockError = new Error('Request failed with status code 404');    axios.get.mockRejectedValue(mockError);    await expect(getBitcoinPrice()).rejects.toThrow('Failed to fetch Bitcoin price');    expect(axios.get).toHaveBeenCalledTimes(1);  });  it('should handle rate limiting', async () => {    const mockRateLimitError = { response: { status: 429 } }; // Example rate limit status code    axios.get.mockRejectedValue(mockRateLimitError);    await expect(getBitcoinPrice()).rejects.toThrow('Rate limit exceeded'); // Or a more specific error message    expect(axios.get).toHaveBeenCalledTimes(1);  });  it('should handle invalid API response', async () => {    const mockInvalidResponse = { data: {} };    axios.get.mockResolvedValue(mockInvalidResponse);    await expect(getBitcoinPrice()).rejects.toThrow('Invalid API response');  });  it('should handle missing Bitcoin data in response', async () => {    const mockMissingData = { data: { bitcoin: {} }};    axios.get.mockResolvedValue(mockMissingData);    await expect(getBitcoinPrice()).rejects.toThrow('Missing Bitcoin price data in API response');  });  it('should handle non-numeric Bitcoin price', async () => {    const mockNonNumericPrice = { data: { bitcoin: { usd: 'abc' } } };    axios.get.mockResolvedValue(mockNonNumericPrice);    await expect(getBitcoinPrice()).rejects.toThrow('Invalid Bitcoin price format');  });});```
[2025-05-16T14:30:29.189Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:30:29.189Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:30:29.190Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Price Data Fetching] Failed on attempt 2: Test generation failed
[2025-05-16T14:30:30.192Z] INFO: üîÅ [TEST - Unit Tests for Price Data Fetching] Attempt 3 of 3
[2025-05-16T14:30:35.392Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the correct fetching and handling of Bitcoin price data from the CoinGecko API, including error handling and rate limiting.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:30:41.103Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the route is here
const axios = require('axios');

jest.mock('axios');

describe('getBitcoinPrice', () => {
  it('should successfully fetch and return Bitcoin price', async () => {
    const mockResponse = {
      data: {
        bitcoin: {
          usd: 20000,
        },
      },
    };
    axios.get.mockResolvedValue(mockResponse);

    const price = await getBitcoinPrice();
    expect(price).toBe(2000
[2025-05-16T14:30:41.104Z] INFO: üß™ Raw test output:
```javascript
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the route is here
const axios = require('axios');

jest.mock('axios');

describe('getBitcoinPrice', () => {
  it('should successfully fetch and return Bitcoin price', async () => {
    const mockResponse = {
      data: {
        bitcoin: {
          usd: 20000,
        },
      },
    };
    axios.get.mockResolvedValue(mockResponse);

    const price = await getBitcoinPrice();
    expect(price).toBe(20000);
    expect(axios.get).toHaveBeenCalledWith('https://api.coingecko.com/api/v3/coins/bitcoin'); // Or your API endpoint
  });

  it('should handle errors during API request', async () => {
    axios.get.mockRejectedValue(new Error('Network Error'));

    await expect(getBitcoinPrice()).rejects.toThrow('Network Error'); // Or a more specific error
  });

  it('should handle invalid API response', async () => {
    const mockResponse = { data: {} };
    axios.get.mockResolvedValue(mockResponse);

    await expect(getBitcoinPrice()).rejects.toThrow('Invalid API response'); // Or a more specific error
  });


  it('should handle rate limiting', async () => {
    const mockError = { response: { status: 429 } }; //Example of a 429 response
    axios.get.mockRejectedValue(mockError);

    await expect(getBitcoinPrice()).rejects.toThrow('Rate limit exceeded'); // Or a more specific error handling based on the API's rate limit response

  });

  it('should handle other HTTP errors', async () => {
    const mockError = { response: { status: 500 } }; // Example of a 500 response
    axios.get.mockRejectedValue(mockError);

    await expect(getBitcoinPrice()).rejects.toThrow('Server Error'); // Or a more specific error handling based on the API's error response.
  });


  it('should handle non-numeric price in API response', async () => {
    const mockResponse = { data: { bitcoin: { usd: 'invalid' } } };
    axios.get.mockResolvedValue(mockResponse);
    await expect(getBitcoinPrice()).rejects.toThrow('Invalid price format');
  });


});

```

[2025-05-16T14:30:41.105Z] INFO: ‚úÖ Cleaned test output:
const { getBitcoinPrice } = require('../backend/routes/bitcoin'); // Assuming the route is hereconst axios = require('axios');jest.mock('axios');describe('getBitcoinPrice', () => {  it('should successfully fetch and return Bitcoin price', async () => {    const mockResponse = {      data: {        bitcoin: {          usd: 20000,        },      },    };    axios.get.mockResolvedValue(mockResponse);    const price = await getBitcoinPrice();    expect(price).toBe(20000);    expect(axios.get).toHaveBeenCalledWith('https://api.coingecko.com/api/v3/coins/bitcoin'); // Or your API endpoint  });  it('should handle errors during API request', async () => {    axios.get.mockRejectedValue(new Error('Network Error'));    await expect(getBitcoinPrice()).rejects.toThrow('Network Error'); // Or a more specific error  });  it('should handle invalid API response', async () => {    const mockResponse = { data: {} };    axios.get.mockResolvedValue(mockResponse);    await expect(getBitcoinPrice()).rejects.toThrow('Invalid API response'); // Or a more specific error  });  it('should handle rate limiting', async () => {    const mockError = { response: { status: 429 } }; //Example of a 429 response    axios.get.mockRejectedValue(mockError);    await expect(getBitcoinPrice()).rejects.toThrow('Rate limit exceeded'); // Or a more specific error handling based on the API's rate limit response  });  it('should handle other HTTP errors', async () => {    const mockError = { response: { status: 500 } }; // Example of a 500 response    axios.get.mockRejectedValue(mockError);    await expect(getBitcoinPrice()).rejects.toThrow('Server Error'); // Or a more specific error handling based on the API's error response.  });  it('should handle non-numeric price in API response', async () => {    const mockResponse = { data: { bitcoin: { usd: 'invalid' } } };    axios.get.mockResolvedValue(mockResponse);    await expect(getBitcoinPrice()).rejects.toThrow('Invalid price format');  });});```
[2025-05-16T14:30:41.106Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:30:41.106Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:30:41.107Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Price Data Fetching] Failed on attempt 3: Test generation failed
[2025-05-16T14:30:43.109Z] ERROR: ‚ùå [TEST - Unit Tests for Price Data Fetching] Failed after 3 retries
[2025-05-16T14:30:43.110Z] ERROR: ‚ùå Testing agent failed permanently: Test generation failed
[2025-05-16T14:30:47.986Z] INFO: üîÅ [TEST - Unit Tests for Technical Indicator Calculations] Attempt 1 of 3
[2025-05-16T14:30:52.911Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the accuracy of the EMA, RSI, MACD, and Bollinger Bands calculations for various input data sets and parameter configurations.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:31:01.917Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { calculateEMA, calculateRSI, calculateMACD, calculateBollingerBands } = require('./indicatorCalculations'); // Assuming these functions exist

describe('Technical Indicator Calculations', () => {
  const testData = [10, 12, 15, 14, 16, 18, 20, 19, 22, 25];

  describe('EMA Calculation', () => {
    it('should calculate EMA correctly for a simple dataset', () => {
      const ema = calculateEMA(testData, 3); // Example period of 3
      expect(ema.length).toBe(testData.length
[2025-05-16T14:31:01.919Z] INFO: üß™ Raw test output:
```javascript
const { calculateEMA, calculateRSI, calculateMACD, calculateBollingerBands } = require('./indicatorCalculations'); // Assuming these functions exist

describe('Technical Indicator Calculations', () => {
  const testData = [10, 12, 15, 14, 16, 18, 20, 19, 22, 25];

  describe('EMA Calculation', () => {
    it('should calculate EMA correctly for a simple dataset', () => {
      const ema = calculateEMA(testData, 3); // Example period of 3
      expect(ema.length).toBe(testData.length);
      // Add assertions to compare EMA values against expected values.  You'll need to calculate these manually or with a reference implementation.  Example:
      expect(ema[ema.length-1]).toBeCloseTo(20.666,2); //Example assertion - replace with actual expected value.
    });

    it('should handle empty input data', () => {
      expect(() => calculateEMA([], 3)).toThrow(); // Or handle gracefully and check the result
    });

    it('should handle invalid period', () => {
      expect(() => calculateEMA(testData, 0)).toThrow();
      expect(() => calculateEMA(testData, -1)).toThrow();
    });

    it('should handle period larger than dataset', () => {
      expect(calculateEMA(testData, testData.length +1).length).toBe(0); // Or throw error depending on implementation.
    });
  });

  describe('RSI Calculation', () => {
    it('should calculate RSI correctly for a simple dataset', () => {
      const rsi = calculateRSI(testData, 14); // Example period of 14
      expect(rsi.length).toBe(testData.length);
      // Add assertions for RSI values.  Example:
      expect(rsi[rsi.length-1]).toBeCloseTo(70, 0); //Example assertion - replace with actual expected value.
    });

    it('should handle empty input data', () => {
      expect(() => calculateRSI([], 14)).toThrow(); // Or handle gracefully
    });

    it('should handle invalid period', () => {
      expect(() => calculateRSI(testData, 0)).toThrow();
      expect(() => calculateRSI(testData, -1)).toThrow();
    });

    it('should handle period larger than dataset', () => {
      expect(calculateRSI(testData, testData.length + 1).length).toBe(0); // Or throw error depending on implementation.
    });
  });


  describe('MACD Calculation', () => {
    it('should calculate MACD correctly for a simple dataset', () => {
      const macd = calculateMACD(testData, 12, 26, 9); // Example periods
      expect(macd.length).toBe(testData.length);
      // Add assertions for MACD values (MACD line, signal line, histogram). Example:
      expect(macd[macd.length-1].MACD).toBeCloseTo(0, 1); // Example assertion - replace with actual expected value.

    });

    it('should handle empty input data', () => {
      expect(() => calculateMACD([], 12, 26, 9)).toThrow(); // Or handle gracefully
    });

    it('should handle invalid periods', () => {
      expect(() => calculateMACD(testData, 0, 26, 9)).toThrow();
      expect(() => calculateMACD(testData, 12, 0, 9)).toThrow();
      expect(() => calculateMACD(testData, 12, 26, 0)).toThrow();
    });
  });


  describe('Bollinger Bands Calculation', () => {
    it('should calculate Bollinger Bands correctly for a simple dataset', () => {
      const bb = calculateBollingerBands(testData, 20, 2); // Example period and standard deviations
      expect(bb.length).toBe(testData.length);
      // Add assertions for Bollinger Bands values (upper, middle, lower bands). Example:
      expect(bb[bb.length-1].upper).toBeCloseTo(29,0); // Example assertion - replace with actual expected value.
    });

    it('should handle empty input data', () => {
      expect(() => calculateBollingerBands([], 20, 2)).toThrow(); // Or handle gracefully
    });

    it('should handle invalid period', () => {
      expect(() => calculateBollingerBands(testData, 0, 2)).toThrow();
      expect(() => calculateBollingerBands(testData, -1, 2)).toThrow();
    });
    it('should handle invalid standard deviation', () => {
      expect(() => calculateBollingerBands(testData, 20, 0)).toThrow();
      expect(() => calculateBollingerBands(testData, 20, -1)).toThrow();
    });
  });
});

```

[2025-05-16T14:31:01.920Z] INFO: ‚úÖ Cleaned test output:
const { calculateEMA, calculateRSI, calculateMACD, calculateBollingerBands } = require('./indicatorCalculations'); // Assuming these functions existdescribe('Technical Indicator Calculations', () => {  const testData = [10, 12, 15, 14, 16, 18, 20, 19, 22, 25];  describe('EMA Calculation', () => {    it('should calculate EMA correctly for a simple dataset', () => {      const ema = calculateEMA(testData, 3); // Example period of 3      expect(ema.length).toBe(testData.length);      // Add assertions to compare EMA values against expected values.  You'll need to calculate these manually or with a reference implementation.  Example:      expect(ema[ema.length-1]).toBeCloseTo(20.666,2); //Example assertion - replace with actual expected value.    });    it('should handle empty input data', () => {      expect(() => calculateEMA([], 3)).toThrow(); // Or handle gracefully and check the result    });    it('should handle invalid period', () => {      expect(() => calculateEMA(testData, 0)).toThrow();      expect(() => calculateEMA(testData, -1)).toThrow();    });    it('should handle period larger than dataset', () => {      expect(calculateEMA(testData, testData.length +1).length).toBe(0); // Or throw error depending on implementation.    });  });  describe('RSI Calculation', () => {    it('should calculate RSI correctly for a simple dataset', () => {      const rsi = calculateRSI(testData, 14); // Example period of 14      expect(rsi.length).toBe(testData.length);      // Add assertions for RSI values.  Example:      expect(rsi[rsi.length-1]).toBeCloseTo(70, 0); //Example assertion - replace with actual expected value.    });    it('should handle empty input data', () => {      expect(() => calculateRSI([], 14)).toThrow(); // Or handle gracefully    });    it('should handle invalid period', () => {      expect(() => calculateRSI(testData, 0)).toThrow();      expect(() => calculateRSI(testData, -1)).toThrow();    });    it('should handle period larger than dataset', () => {      expect(calculateRSI(testData, testData.length + 1).length).toBe(0); // Or throw error depending on implementation.    });  });  describe('MACD Calculation', () => {    it('should calculate MACD correctly for a simple dataset', () => {      const macd = calculateMACD(testData, 12, 26, 9); // Example periods      expect(macd.length).toBe(testData.length);      // Add assertions for MACD values (MACD line, signal line, histogram). Example:      expect(macd[macd.length-1].MACD).toBeCloseTo(0, 1); // Example assertion - replace with actual expected value.    });    it('should handle empty input data', () => {      expect(() => calculateMACD([], 12, 26, 9)).toThrow(); // Or handle gracefully    });    it('should handle invalid periods', () => {      expect(() => calculateMACD(testData, 0, 26, 9)).toThrow();      expect(() => calculateMACD(testData, 12, 0, 9)).toThrow();      expect(() => calculateMACD(testData, 12, 26, 0)).toThrow();    });  });  describe('Bollinger Bands Calculation', () => {    it('should calculate Bollinger Bands correctly for a simple dataset', () => {      const bb = calculateBollingerBands(testData, 20, 2); // Example period and standard deviations      expect(bb.length).toBe(testData.length);      // Add assertions for Bollinger Bands values (upper, middle, lower bands). Example:      expect(bb[bb.length-1].upper).toBeCloseTo(29,0); // Example assertion - replace with actual expected value.    });    it('should handle empty input data', () => {      expect(() => calculateBollingerBands([], 20, 2)).toThrow(); // Or handle gracefully    });    it('should handle invalid period', () => {      expect(() => calculateBollingerBands(testData, 0, 2)).toThrow();      expect(() => calculateBollingerBands(testData, -1, 2)).toThrow();    });    it('should handle invalid standard deviation', () => {      expect(() => calculateBollingerBands(testData, 20, 0)).toThrow();      expect(() => calculateBollingerBands(testData, 20, -1)).toThrow();    });  });});```
[2025-05-16T14:31:01.920Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:31:01.920Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:31:01.921Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Technical Indicator Calculations] Failed on attempt 1: Test generation failed
[2025-05-16T14:31:02.421Z] INFO: üîÅ [TEST - Unit Tests for Technical Indicator Calculations] Attempt 2 of 3
[2025-05-16T14:31:07.431Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the accuracy of the EMA, RSI, MACD, and Bollinger Bands calculations for various input data sets and parameter configurations.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:31:21.069Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { EMA, RSI, MACD, BollingerBands } = require('./indicatorCalculations'); // Assuming these functions exist

describe('Technical Indicator Calculations', () => {
  describe('EMA (Exponential Moving Average)', () => {
    it('should calculate EMA correctly for a simple dataset', () => {
      const data = [10, 12, 15, 14, 16];
      const period = 2;
      const ema = EMA(data, period);
      expect(ema).toBeCloseTo(14.2, 1); // Example expected value, adjust as needed
    });

[2025-05-16T14:31:21.070Z] INFO: üß™ Raw test output:
```javascript
const { EMA, RSI, MACD, BollingerBands } = require('./indicatorCalculations'); // Assuming these functions exist

describe('Technical Indicator Calculations', () => {
  describe('EMA (Exponential Moving Average)', () => {
    it('should calculate EMA correctly for a simple dataset', () => {
      const data = [10, 12, 15, 14, 16];
      const period = 2;
      const ema = EMA(data, period);
      expect(ema).toBeCloseTo(14.2, 1); // Example expected value, adjust as needed
    });

    it('should handle empty dataset', () => {
      expect(() => EMA([], 2)).toThrow(); //or return specific value based on implementation
    });

    it('should handle period larger than dataset length', () => {
      const data = [10, 12, 15];
      const period = 4;
      expect(() => EMA(data, period)).toThrow(); //or return specific value based on implementation

    });

    it('should handle invalid period', () => {
      const data = [10, 12, 15];
      const period = 0;
      expect(() => EMA(data, period)).toThrow(); //or return specific value based on implementation
    });

    it('should handle negative data points', () => {
        const data = [10, -2, 15, -5, 16];
        const period = 2;
        const ema = EMA(data, period);
        //Expect appropriate value based on your EMA calculation handling of negative values.
        expect(ema).toBeDefined();
    })
  });

  describe('RSI (Relative Strength Index)', () => {
    it('should calculate RSI correctly for a sample dataset', () => {
      const data = [10, 12, 15, 14, 16, 18, 17, 19, 20];
      const period = 14;
      const rsi = RSI(data, period);
      expect(rsi).toBeGreaterThanOrEqual(0);
      expect(rsi).toBeLessThanOrEqual(100);
      // Add more specific assertions based on expected RSI values for the sample data
    });
    it('should handle empty dataset', () => {
      expect(() => RSI([], 14)).toThrow(); //or return specific value based on implementation
    });
    it('should handle period larger than dataset length', () => {
      const data = [10, 12, 15];
      const period = 14;
      expect(() => RSI(data, period)).toThrow();//or return specific value based on implementation
    });
    it('should handle invalid period', () => {
      const data = [10, 12, 15];
      const period = 0;
      expect(() => RSI(data, period)).toThrow();//or return specific value based on implementation
    });
  });

  describe('MACD (Moving Average Convergence Divergence)', () => {
    it('should calculate MACD correctly for a sample dataset', () => {
      const data = [10, 12, 15, 14, 16, 18, 17, 19, 20, 22, 21, 23, 25, 24]; //Example dataset, adjust as needed
      const fastPeriod = 12;
      const slowPeriod = 26;
      const signalPeriod = 9;
      const macd = MACD(data, fastPeriod, slowPeriod, signalPeriod);
      expect(macd).toBeDefined(); //Add specific assertions based on expected MACD values. Expect object with MACD, signal, and histogram.
      expect(macd.MACD).toBeDefined();
      expect(macd.signal).toBeDefined();
      expect(macd.histogram).toBeDefined();
    });
    it('should handle empty dataset', () => {
      expect(() => MACD([], 12, 26, 9)).toThrow(); //or return specific value based on implementation
    });
    it('should handle insufficient data for periods', () => {
      const data = [10,12,15];
      expect(() => MACD(data, 12,26,9)).toThrow();//or return specific value based on implementation
    })
    it('should handle invalid periods', () => {
      const data = [10,12,15,16,18,20];
      expect(() => MACD(data, 0,26,9)).toThrow();//or return specific value based on implementation
      expect(() => MACD(data, 12,0,9)).toThrow();//or return specific value based on implementation
      expect(() => MACD(data, 12,26,0)).toThrow();//or return specific value based on implementation

    })
  });

  describe('Bollinger Bands', () => {
    it('should calculate Bollinger Bands correctly for a sample dataset', () => {
      const data = [10, 12, 15, 14, 16, 18, 17, 19, 20, 22, 21, 23, 25, 24];
      const period = 20;
      const stdDev = 2;
      const bands = BollingerBands(data, period, stdDev);
      expect(bands).toBeDefined(); // Expect an object with upper, middle, and lower bands.
      expect(bands.upper).toBeDefined();
      expect(bands.middle).toBeDefined();
      expect(bands.lower).toBeDefined();

    });
    it('should handle empty dataset', () => {
      expect(() => BollingerBands([], 20, 2)).toThrow(); //or return specific value based on implementation
    });
    it('should handle period larger than dataset', () => {
      const data = [10, 12, 15];
      expect(() => BollingerBands(data, 20, 2)).toThrow();//or return specific value based on implementation
    });
    it('should handle invalid period or stdDev', () => {
      const data = [10, 12, 15, 16, 18, 20];
      expect(() => BollingerBands(data, 0, 2)).toThrow();//or return specific value based on implementation
      expect(() => BollingerBands(data, 20, 0)).toThrow();//or return specific value based on implementation
    })
  });
});

```

[2025-05-16T14:31:21.071Z] INFO: ‚úÖ Cleaned test output:
const { EMA, RSI, MACD, BollingerBands } = require('./indicatorCalculations'); // Assuming these functions existdescribe('Technical Indicator Calculations', () => {  describe('EMA (Exponential Moving Average)', () => {    it('should calculate EMA correctly for a simple dataset', () => {      const data = [10, 12, 15, 14, 16];      const period = 2;      const ema = EMA(data, period);      expect(ema).toBeCloseTo(14.2, 1); // Example expected value, adjust as needed    });    it('should handle empty dataset', () => {      expect(() => EMA([], 2)).toThrow(); //or return specific value based on implementation    });    it('should handle period larger than dataset length', () => {      const data = [10, 12, 15];      const period = 4;      expect(() => EMA(data, period)).toThrow(); //or return specific value based on implementation    });    it('should handle invalid period', () => {      const data = [10, 12, 15];      const period = 0;      expect(() => EMA(data, period)).toThrow(); //or return specific value based on implementation    });    it('should handle negative data points', () => {        const data = [10, -2, 15, -5, 16];        const period = 2;        const ema = EMA(data, period);        //Expect appropriate value based on your EMA calculation handling of negative values.        expect(ema).toBeDefined();    })  });  describe('RSI (Relative Strength Index)', () => {    it('should calculate RSI correctly for a sample dataset', () => {      const data = [10, 12, 15, 14, 16, 18, 17, 19, 20];      const period = 14;      const rsi = RSI(data, period);      expect(rsi).toBeGreaterThanOrEqual(0);      expect(rsi).toBeLessThanOrEqual(100);      // Add more specific assertions based on expected RSI values for the sample data    });    it('should handle empty dataset', () => {      expect(() => RSI([], 14)).toThrow(); //or return specific value based on implementation    });    it('should handle period larger than dataset length', () => {      const data = [10, 12, 15];      const period = 14;      expect(() => RSI(data, period)).toThrow();//or return specific value based on implementation    });    it('should handle invalid period', () => {      const data = [10, 12, 15];      const period = 0;      expect(() => RSI(data, period)).toThrow();//or return specific value based on implementation    });  });  describe('MACD (Moving Average Convergence Divergence)', () => {    it('should calculate MACD correctly for a sample dataset', () => {      const data = [10, 12, 15, 14, 16, 18, 17, 19, 20, 22, 21, 23, 25, 24]; //Example dataset, adjust as needed      const fastPeriod = 12;      const slowPeriod = 26;      const signalPeriod = 9;      const macd = MACD(data, fastPeriod, slowPeriod, signalPeriod);      expect(macd).toBeDefined(); //Add specific assertions based on expected MACD values. Expect object with MACD, signal, and histogram.      expect(macd.MACD).toBeDefined();      expect(macd.signal).toBeDefined();      expect(macd.histogram).toBeDefined();    });    it('should handle empty dataset', () => {      expect(() => MACD([], 12, 26, 9)).toThrow(); //or return specific value based on implementation    });    it('should handle insufficient data for periods', () => {      const data = [10,12,15];      expect(() => MACD(data, 12,26,9)).toThrow();//or return specific value based on implementation    })    it('should handle invalid periods', () => {      const data = [10,12,15,16,18,20];      expect(() => MACD(data, 0,26,9)).toThrow();//or return specific value based on implementation      expect(() => MACD(data, 12,0,9)).toThrow();//or return specific value based on implementation      expect(() => MACD(data, 12,26,0)).toThrow();//or return specific value based on implementation    })  });  describe('Bollinger Bands', () => {    it('should calculate Bollinger Bands correctly for a sample dataset', () => {      const data = [10, 12, 15, 14, 16, 18, 17, 19, 20, 22, 21, 23, 25, 24];      const period = 20;      const stdDev = 2;      const bands = BollingerBands(data, period, stdDev);      expect(bands).toBeDefined(); // Expect an object with upper, middle, and lower bands.      expect(bands.upper).toBeDefined();      expect(bands.middle).toBeDefined();      expect(bands.lower).toBeDefined();    });    it('should handle empty dataset', () => {      expect(() => BollingerBands([], 20, 2)).toThrow(); //or return specific value based on implementation    });    it('should handle period larger than dataset', () => {      const data = [10, 12, 15];      expect(() => BollingerBands(data, 20, 2)).toThrow();//or return specific value based on implementation    });    it('should handle invalid period or stdDev', () => {      const data = [10, 12, 15, 16, 18, 20];      expect(() => BollingerBands(data, 0, 2)).toThrow();//or return specific value based on implementation      expect(() => BollingerBands(data, 20, 0)).toThrow();//or return specific value based on implementation    })  });});```
[2025-05-16T14:31:21.072Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:31:21.073Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:31:21.073Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Technical Indicator Calculations] Failed on attempt 2: Test generation failed
[2025-05-16T14:31:22.073Z] INFO: üîÅ [TEST - Unit Tests for Technical Indicator Calculations] Attempt 3 of 3
[2025-05-16T14:31:27.308Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the accuracy of the EMA, RSI, MACD, and Bollinger Bands calculations for various input data sets and parameter configurations.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:31:37.963Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { EMA, RSI, MACD, BollingerBands } = require('./indicators'); // Assuming these functions exist

describe('Technical Indicators', () => {
  const data = [10, 12, 15, 14, 16, 18, 20, 19, 22, 25];

  describe('EMA', () => {
    it('should calculate EMA correctly for a simple dataset', () => {
      const period = 3;
      const ema = EMA(data, period);
      expect(ema.length).toBe(data.length);
      // Add specific assertions based on expected EMA values for this dataset and 
[2025-05-16T14:31:37.965Z] INFO: üß™ Raw test output:
```javascript
const { EMA, RSI, MACD, BollingerBands } = require('./indicators'); // Assuming these functions exist

describe('Technical Indicators', () => {
  const data = [10, 12, 15, 14, 16, 18, 20, 19, 22, 25];

  describe('EMA', () => {
    it('should calculate EMA correctly for a simple dataset', () => {
      const period = 3;
      const ema = EMA(data, period);
      expect(ema.length).toBe(data.length);
      // Add specific assertions based on expected EMA values for this dataset and period.  This requires pre-calculating the expected results.  Example below:
      expect(ema[ema.length -1]).toBeCloseTo(19.666, 2); //Example - replace with accurate value
    });

    it('should handle edge cases: empty data', () => {
      expect(() => EMA([], 3)).toThrowError(); // Or handle gracefully if appropriate
    });
    it('should handle edge cases: period > data length', () => {
      expect(() => EMA(data, 15)).toThrowError(); // Or handle gracefully if appropriate
    });
    it('should handle edge cases: invalid period', () => {
      expect(() => EMA(data, 0)).toThrowError(); // Or handle gracefully if appropriate
      expect(() => EMA(data, -1)).toThrowError(); // Or handle gracefully if appropriate
    });
  });


  describe('RSI', () => {
    it('should calculate RSI correctly for a simple dataset', () => {
      const period = 14; // Common RSI period
      const rsi = RSI(data, period);
      expect(rsi.length).toBe(data.length);
      // Add specific assertions based on expected RSI values.  Requires pre-calculation. Example below:
      expect(rsi[rsi.length - 1]).toBeCloseTo(75.00, 2); //Example - replace with accurate value

    });
    it('should handle edge cases: empty data', () => {
      expect(() => RSI([], 14)).toThrowError(); // Or handle gracefully
    });
    it('should handle edge cases: period > data length', () => {
      expect(() => RSI(data, 20)).toThrowError(); // Or handle gracefully
    });
    it('should handle edge cases: invalid period', () => {
      expect(() => RSI(data, 0)).toThrowError(); // Or handle gracefully
      expect(() => RSI(data, -1)).toThrowError(); // Or handle gracefully

    });

  });

  describe('MACD', () => {
    it('should calculate MACD correctly for a simple dataset', () => {
      const fastPeriod = 12;
      const slowPeriod = 26;
      const signalPeriod = 9;
      const macd = MACD(data, fastPeriod, slowPeriod, signalPeriod);
      expect(macd.length).toBe(data.length);
      // Add assertions for MACD, signal, and histogram values. Requires pre-calculation. Example below:
      expect(macd[macd.length - 1].MACD).toBeCloseTo(0.00, 2); //Example - replace with accurate value
    });
    it('should handle edge cases: empty data', () => {
      expect(() => MACD([], 12, 26, 9)).toThrowError(); // Or handle gracefully
    });
    it('should handle edge cases: invalid periods', () => {
      expect(() => MACD(data, 0, 26, 9)).toThrowError(); // Or handle gracefully
      expect(() => MACD(data, 12, 0, 9)).toThrowError(); // Or handle gracefully
      expect(() => MACD(data, 12, 26, 0)).toThrowError(); // Or handle gracefully

    });
  });

  describe('BollingerBands', () => {
    it('should calculate Bollinger Bands correctly for a simple dataset', () => {
      const period = 20;
      const stdDev = 2;
      const bands = BollingerBands(data, period, stdDev);
      expect(bands.length).toBe(data.length);
      // Add assertions for upper, middle, and lower bands. Requires pre-calculation. Example below:
      expect(bands[bands.length - 1].middle).toBeCloseTo(17.00, 2); //Example - replace with accurate value
    });
    it('should handle edge cases: empty data', () => {
      expect(() => BollingerBands([], 20, 2)).toThrowError(); // Or handle gracefully
    });
    it('should handle edge cases: period > data length', () => {
      expect(() => BollingerBands(data, 30, 2)).toThrowError(); // Or handle gracefully
    });
    it('should handle edge cases: invalid period or stdDev', () => {
      expect(() => BollingerBands(data, 0, 2)).toThrowError(); // Or handle gracefully
      expect(() => BollingerBands(data, 20, 0)).toThrowError(); // Or handle gracefully
      expect(() => BollingerBands(data, 20, -1)).toThrowError(); // Or handle gracefully
    });
  });
});

```

[2025-05-16T14:31:37.966Z] INFO: ‚úÖ Cleaned test output:
const { EMA, RSI, MACD, BollingerBands } = require('./indicators'); // Assuming these functions existdescribe('Technical Indicators', () => {  const data = [10, 12, 15, 14, 16, 18, 20, 19, 22, 25];  describe('EMA', () => {    it('should calculate EMA correctly for a simple dataset', () => {      const period = 3;      const ema = EMA(data, period);      expect(ema.length).toBe(data.length);      // Add specific assertions based on expected EMA values for this dataset and period.  This requires pre-calculating the expected results.  Example below:      expect(ema[ema.length -1]).toBeCloseTo(19.666, 2); //Example - replace with accurate value    });    it('should handle edge cases: empty data', () => {      expect(() => EMA([], 3)).toThrowError(); // Or handle gracefully if appropriate    });    it('should handle edge cases: period > data length', () => {      expect(() => EMA(data, 15)).toThrowError(); // Or handle gracefully if appropriate    });    it('should handle edge cases: invalid period', () => {      expect(() => EMA(data, 0)).toThrowError(); // Or handle gracefully if appropriate      expect(() => EMA(data, -1)).toThrowError(); // Or handle gracefully if appropriate    });  });  describe('RSI', () => {    it('should calculate RSI correctly for a simple dataset', () => {      const period = 14; // Common RSI period      const rsi = RSI(data, period);      expect(rsi.length).toBe(data.length);      // Add specific assertions based on expected RSI values.  Requires pre-calculation. Example below:      expect(rsi[rsi.length - 1]).toBeCloseTo(75.00, 2); //Example - replace with accurate value    });    it('should handle edge cases: empty data', () => {      expect(() => RSI([], 14)).toThrowError(); // Or handle gracefully    });    it('should handle edge cases: period > data length', () => {      expect(() => RSI(data, 20)).toThrowError(); // Or handle gracefully    });    it('should handle edge cases: invalid period', () => {      expect(() => RSI(data, 0)).toThrowError(); // Or handle gracefully      expect(() => RSI(data, -1)).toThrowError(); // Or handle gracefully    });  });  describe('MACD', () => {    it('should calculate MACD correctly for a simple dataset', () => {      const fastPeriod = 12;      const slowPeriod = 26;      const signalPeriod = 9;      const macd = MACD(data, fastPeriod, slowPeriod, signalPeriod);      expect(macd.length).toBe(data.length);      // Add assertions for MACD, signal, and histogram values. Requires pre-calculation. Example below:      expect(macd[macd.length - 1].MACD).toBeCloseTo(0.00, 2); //Example - replace with accurate value    });    it('should handle edge cases: empty data', () => {      expect(() => MACD([], 12, 26, 9)).toThrowError(); // Or handle gracefully    });    it('should handle edge cases: invalid periods', () => {      expect(() => MACD(data, 0, 26, 9)).toThrowError(); // Or handle gracefully      expect(() => MACD(data, 12, 0, 9)).toThrowError(); // Or handle gracefully      expect(() => MACD(data, 12, 26, 0)).toThrowError(); // Or handle gracefully    });  });  describe('BollingerBands', () => {    it('should calculate Bollinger Bands correctly for a simple dataset', () => {      const period = 20;      const stdDev = 2;      const bands = BollingerBands(data, period, stdDev);      expect(bands.length).toBe(data.length);      // Add assertions for upper, middle, and lower bands. Requires pre-calculation. Example below:      expect(bands[bands.length - 1].middle).toBeCloseTo(17.00, 2); //Example - replace with accurate value    });    it('should handle edge cases: empty data', () => {      expect(() => BollingerBands([], 20, 2)).toThrowError(); // Or handle gracefully    });    it('should handle edge cases: period > data length', () => {      expect(() => BollingerBands(data, 30, 2)).toThrowError(); // Or handle gracefully    });    it('should handle edge cases: invalid period or stdDev', () => {      expect(() => BollingerBands(data, 0, 2)).toThrowError(); // Or handle gracefully      expect(() => BollingerBands(data, 20, 0)).toThrowError(); // Or handle gracefully      expect(() => BollingerBands(data, 20, -1)).toThrowError(); // Or handle gracefully    });  });});```
[2025-05-16T14:31:37.967Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:31:37.968Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:31:37.968Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Technical Indicator Calculations] Failed on attempt 3: Test generation failed
[2025-05-16T14:31:39.970Z] ERROR: ‚ùå [TEST - Unit Tests for Technical Indicator Calculations] Failed after 3 retries
[2025-05-16T14:31:39.972Z] ERROR: ‚ùå Testing agent failed permanently: Test generation failed
[2025-05-16T14:31:45.429Z] INFO: üîÅ [TEST - Unit Tests for Signal Generation Logic] Attempt 1 of 3
[2025-05-16T14:31:50.556Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the correctness of the buy/sell signal generation logic based on different indicator combinations and thresholds.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:31:58.341Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { generateBuySellSignal } = require('../src/signalGenerator'); // Assuming signal generation logic is in signalGenerator.js

describe('generateBuySellSignal', () => {
  it('should generate a buy signal when RSI is below 30 and MACD is above signal line', () => {
    const indicators = {
      rsi: 25,
      macd: 1,
      signal: 0.5,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('buy');
  });

  it('s
[2025-05-16T14:31:58.343Z] INFO: üß™ Raw test output:
```javascript
const { generateBuySellSignal } = require('../src/signalGenerator'); // Assuming signal generation logic is in signalGenerator.js

describe('generateBuySellSignal', () => {
  it('should generate a buy signal when RSI is below 30 and MACD is above signal line', () => {
    const indicators = {
      rsi: 25,
      macd: 1,
      signal: 0.5,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('buy');
  });

  it('should generate a sell signal when RSI is above 70 and MACD is below signal line', () => {
    const indicators = {
      rsi: 75,
      macd: 0.5,
      signal: 1,
    };
    const thresholds = { rsiSell: 70, macdSell: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('sell');
  });

  it('should generate a hold signal when RSI and MACD do not meet buy or sell conditions', () => {
    const indicators = {
      rsi: 50,
      macd: 0.8,
      signal: 0.9,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0, rsiSell: 70, macdSell: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold');
  });

  it('should handle missing indicator values gracefully', () => {
    const indicators = {
      rsi: 25,
      macd: 1,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold'); // Or throw an error, depending on requirements.
  });

  it('should handle invalid indicator values gracefully', () => {
    const indicators = {
      rsi: -10, // Invalid RSI value
      macd: 1,
      signal: 0.5,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold'); // Or throw an error, depending on requirements.
  });


  it('should generate a buy signal when only the MACD condition is met', () => {
    const indicators = {
      rsi: 50,
      macd: 1,
      signal: 0.5,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('buy');
  });

  it('should generate a sell signal when only the RSI condition is met', () => {
    const indicators = {
      rsi: 75,
      macd: 0.5,
      signal: 1,
    };
    const thresholds = { rsiSell: 70, macdSell: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('sell');
  });

  it('should handle edge case where RSI is exactly at the threshold', () => {
    const indicators = {
      rsi: 30,
      macd: 1,
      signal: 0.5,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('buy'); // Or 'hold', depending on requirements.
  });

  it('should handle edge case where MACD is exactly at the signal line', () => {
    const indicators = {
      rsi: 25,
      macd: 0.5,
      signal: 0.5,
    };
    const thresholds = { rsiBuy: 30, macdBuy: 0 };
    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold'); // Or 'buy', depending on requirements.
  });

  // Add more tests for other indicator combinations and edge cases as needed.  Consider adding tests for other indicators like Stochastic Oscillator, Bollinger Bands etc. if they are part of the signal generation.
});

```

[2025-05-16T14:31:58.344Z] INFO: ‚úÖ Cleaned test output:
const { generateBuySellSignal } = require('../src/signalGenerator'); // Assuming signal generation logic is in signalGenerator.jsdescribe('generateBuySellSignal', () => {  it('should generate a buy signal when RSI is below 30 and MACD is above signal line', () => {    const indicators = {      rsi: 25,      macd: 1,      signal: 0.5,    };    const thresholds = { rsiBuy: 30, macdBuy: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('buy');  });  it('should generate a sell signal when RSI is above 70 and MACD is below signal line', () => {    const indicators = {      rsi: 75,      macd: 0.5,      signal: 1,    };    const thresholds = { rsiSell: 70, macdSell: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('sell');  });  it('should generate a hold signal when RSI and MACD do not meet buy or sell conditions', () => {    const indicators = {      rsi: 50,      macd: 0.8,      signal: 0.9,    };    const thresholds = { rsiBuy: 30, macdBuy: 0, rsiSell: 70, macdSell: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold');  });  it('should handle missing indicator values gracefully', () => {    const indicators = {      rsi: 25,      macd: 1,    };    const thresholds = { rsiBuy: 30, macdBuy: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold'); // Or throw an error, depending on requirements.  });  it('should handle invalid indicator values gracefully', () => {    const indicators = {      rsi: -10, // Invalid RSI value      macd: 1,      signal: 0.5,    };    const thresholds = { rsiBuy: 30, macdBuy: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold'); // Or throw an error, depending on requirements.  });  it('should generate a buy signal when only the MACD condition is met', () => {    const indicators = {      rsi: 50,      macd: 1,      signal: 0.5,    };    const thresholds = { rsiBuy: 30, macdBuy: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('buy');  });  it('should generate a sell signal when only the RSI condition is met', () => {    const indicators = {      rsi: 75,      macd: 0.5,      signal: 1,    };    const thresholds = { rsiSell: 70, macdSell: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('sell');  });  it('should handle edge case where RSI is exactly at the threshold', () => {    const indicators = {      rsi: 30,      macd: 1,      signal: 0.5,    };    const thresholds = { rsiBuy: 30, macdBuy: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('buy'); // Or 'hold', depending on requirements.  });  it('should handle edge case where MACD is exactly at the signal line', () => {    const indicators = {      rsi: 25,      macd: 0.5,      signal: 0.5,    };    const thresholds = { rsiBuy: 30, macdBuy: 0 };    expect(generateBuySellSignal(indicators, thresholds)).toBe('hold'); // Or 'buy', depending on requirements.  });  // Add more tests for other indicator combinations and edge cases as needed.  Consider adding tests for other indicators like Stochastic Oscillator, Bollinger Bands etc. if they are part of the signal generation.});```
[2025-05-16T14:31:58.345Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:31:58.346Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:31:58.346Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Signal Generation Logic] Failed on attempt 1: Test generation failed
[2025-05-16T14:31:58.847Z] INFO: üîÅ [TEST - Unit Tests for Signal Generation Logic] Attempt 2 of 3
[2025-05-16T14:32:04.053Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the correctness of the buy/sell signal generation logic based on different indicator combinations and thresholds.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:32:11.717Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { generateBuySellSignal } = require('./signalGenerator'); // Assuming this is where the logic resides

describe('generateBuySellSignal', () => {
  it('should return "buy" when RSI is below 30 and MACD is above signal line', () => {
    const rsi = 25;
    const macd = 1;
    const signal = 0.5;
    expect(generateBuySellSignal(rsi, macd, signal, 30, 0)).toBe('buy');
  });

  it('should return "sell" when RSI is above 70 and MACD is below signal line', () => {
    const rsi = 
[2025-05-16T14:32:11.718Z] INFO: üß™ Raw test output:
```javascript
const { generateBuySellSignal } = require('./signalGenerator'); // Assuming this is where the logic resides

describe('generateBuySellSignal', () => {
  it('should return "buy" when RSI is below 30 and MACD is above signal line', () => {
    const rsi = 25;
    const macd = 1;
    const signal = 0.5;
    expect(generateBuySellSignal(rsi, macd, signal, 30, 0)).toBe('buy');
  });

  it('should return "sell" when RSI is above 70 and MACD is below signal line', () => {
    const rsi = 75;
    const macd = -1;
    const signal = -0.5;
    expect(generateBuySellSignal(rsi, macd, signal, 70, 0)).toBe('sell');
  });

  it('should return "hold" when RSI is between 30 and 70 and MACD is around signal line', () => {
    const rsi = 50;
    const macd = 0.1;
    const signal = 0.05;
    expect(generateBuySellSignal(rsi, macd, signal, 70, 30)).toBe('hold');
  });

  it('should return "hold" when RSI is below 30 but MACD is below signal line', () => {
    const rsi = 25;
    const macd = -1;
    const signal = -0.5;
    expect(generateBuySellSignal(rsi, macd, signal, 70, 30)).toBe('hold');
  });

  it('should return "hold" when RSI is above 70 but MACD is above signal line', () => {
    const rsi = 75;
    const macd = 1;
    const signal = 0.5;
    expect(generateBuySellSignal(rsi, macd, signal, 70, 30)).toBe('hold');
  });

  it('should handle undefined values gracefully and return "hold"', () => {
    expect(generateBuySellSignal(undefined, undefined, undefined, 70, 30)).toBe('hold');
  });

  it('should handle NaN values gracefully and return "hold"', () => {
    expect(generateBuySellSignal(NaN, NaN, NaN, 70, 30)).toBe('hold');
  });


  it('should use custom thresholds correctly', () => {
    const rsi = 40;
    const macd = 0.8;
    const signal = 0.5;
    const overbought = 60;
    const oversold = 40;
    expect(generateBuySellSignal(rsi, macd, signal, overbought, oversold)).toBe('buy');
  });


  it('should return "buy" if macd crosses above signal line, even if RSI is above oversold', () => {
    const rsi = 45;
    const macd = 0.8;
    const signal = 0.5;
    const overbought = 70;
    const oversold = 30;
    expect(generateBuySellSignal(rsi, macd, signal, overbought, oversold)).toBe('buy');
  });

  it('should return "sell" if macd crosses below signal line, even if RSI is below overbought', () => {
    const rsi = 65;
    const macd = -0.8;
    const signal = -0.5;
    const overbought = 70;
    const oversold = 30;
    expect(generateBuySellSignal(rsi, macd, signal, overbought, oversold)).toBe('sell');
  });

});

```

[2025-05-16T14:32:11.719Z] INFO: ‚úÖ Cleaned test output:
const { generateBuySellSignal } = require('./signalGenerator'); // Assuming this is where the logic residesdescribe('generateBuySellSignal', () => {  it('should return "buy" when RSI is below 30 and MACD is above signal line', () => {    const rsi = 25;    const macd = 1;    const signal = 0.5;    expect(generateBuySellSignal(rsi, macd, signal, 30, 0)).toBe('buy');  });  it('should return "sell" when RSI is above 70 and MACD is below signal line', () => {    const rsi = 75;    const macd = -1;    const signal = -0.5;    expect(generateBuySellSignal(rsi, macd, signal, 70, 0)).toBe('sell');  });  it('should return "hold" when RSI is between 30 and 70 and MACD is around signal line', () => {    const rsi = 50;    const macd = 0.1;    const signal = 0.05;    expect(generateBuySellSignal(rsi, macd, signal, 70, 30)).toBe('hold');  });  it('should return "hold" when RSI is below 30 but MACD is below signal line', () => {    const rsi = 25;    const macd = -1;    const signal = -0.5;    expect(generateBuySellSignal(rsi, macd, signal, 70, 30)).toBe('hold');  });  it('should return "hold" when RSI is above 70 but MACD is above signal line', () => {    const rsi = 75;    const macd = 1;    const signal = 0.5;    expect(generateBuySellSignal(rsi, macd, signal, 70, 30)).toBe('hold');  });  it('should handle undefined values gracefully and return "hold"', () => {    expect(generateBuySellSignal(undefined, undefined, undefined, 70, 30)).toBe('hold');  });  it('should handle NaN values gracefully and return "hold"', () => {    expect(generateBuySellSignal(NaN, NaN, NaN, 70, 30)).toBe('hold');  });  it('should use custom thresholds correctly', () => {    const rsi = 40;    const macd = 0.8;    const signal = 0.5;    const overbought = 60;    const oversold = 40;    expect(generateBuySellSignal(rsi, macd, signal, overbought, oversold)).toBe('buy');  });  it('should return "buy" if macd crosses above signal line, even if RSI is above oversold', () => {    const rsi = 45;    const macd = 0.8;    const signal = 0.5;    const overbought = 70;    const oversold = 30;    expect(generateBuySellSignal(rsi, macd, signal, overbought, oversold)).toBe('buy');  });  it('should return "sell" if macd crosses below signal line, even if RSI is below overbought', () => {    const rsi = 65;    const macd = -0.8;    const signal = -0.5;    const overbought = 70;    const oversold = 30;    expect(generateBuySellSignal(rsi, macd, signal, overbought, oversold)).toBe('sell');  });});```
[2025-05-16T14:32:11.720Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:32:11.720Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:32:11.721Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Signal Generation Logic] Failed on attempt 2: Test generation failed
[2025-05-16T14:32:12.721Z] INFO: üîÅ [TEST - Unit Tests for Signal Generation Logic] Attempt 3 of 3
[2025-05-16T14:32:17.794Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write unit tests to verify the correctness of the buy/sell signal generation logic based on different indicator combinations and thresholds.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:32:23.939Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { generateBuySellSignal } = require('../src/signalGenerator'); // Replace with actual path

describe('generateBuySellSignal', () => {
  it('should generate a buy signal when RSI is below 30 and MACD is above signal line', () => {
    const rsi = 25;
    const macd = 1;
    const signal = 0.5;
    const threshold = 30;
    const result = generateBuySellSignal(rsi, macd, signal, threshold);
    expect(result).toBe('buy');
  });

  it('should generate a sell signal when RSI is a
[2025-05-16T14:32:23.941Z] INFO: üß™ Raw test output:
```javascript
const { generateBuySellSignal } = require('../src/signalGenerator'); // Replace with actual path

describe('generateBuySellSignal', () => {
  it('should generate a buy signal when RSI is below 30 and MACD is above signal line', () => {
    const rsi = 25;
    const macd = 1;
    const signal = 0.5;
    const threshold = 30;
    const result = generateBuySellSignal(rsi, macd, signal, threshold);
    expect(result).toBe('buy');
  });

  it('should generate a sell signal when RSI is above 70 and MACD is below signal line', () => {
    const rsi = 75;
    const macd = -1;
    const signal = -0.5;
    const threshold = 70;
    const result = generateBuySellSignal(rsi, macd, signal, threshold);
    expect(result).toBe('sell');
  });

  it('should generate a hold signal when RSI is between 30 and 70 and MACD is around signal line', () => {
    const rsi = 50;
    const macd = 0.1;
    const signal = 0.05;
    const threshold = 30;
    const result = generateBuySellSignal(rsi, macd, signal, threshold);
    expect(result).toBe('hold');
  });

  it('should handle edge cases like RSI and MACD values outside typical range', () => {
    const rsi = 100; //Edge case for RSI
    const macd = 10; //Edge case for MACD
    const signal = 0.5;
    const threshold = 30;
    const result = generateBuySellSignal(rsi, macd, signal, threshold);
    expect(result).toBe('sell'); // Or throw an error, depending on requirements.  Should be handled gracefully
  });


  it('should handle NaN or undefined values gracefully', () => {
    const rsi = NaN;
    const macd = undefined;
    const signal = 0.5;
    const threshold = 30;
    expect(() => generateBuySellSignal(rsi, macd, signal, threshold)).toThrow(); // Expecting an error or specific return value
  });


  it('should generate a buy signal when RSI is below threshold and MACD is above signal line, regardless of positive/negative MACD values', () => {
    const rsi = 25;
    const macd = -0.8; // Negative MACD, still above the signal line in this case
    const signal = -1;
    const threshold = 30;
    const result = generateBuySellSignal(rsi, macd, signal, threshold);
    expect(result).toBe('buy');
  });

  it('should use the provided threshold values correctly', () => {
      const rsi = 35;
      const macd = 0.1;
      const signal = 0.05;
      const threshold = 35; //Setting the threshold to match the RSI value
      const result = generateBuySellSignal(rsi, macd, signal, threshold);
      expect(result).toBe('hold');
  });

});


```

[2025-05-16T14:32:23.941Z] INFO: ‚úÖ Cleaned test output:
const { generateBuySellSignal } = require('../src/signalGenerator'); // Replace with actual pathdescribe('generateBuySellSignal', () => {  it('should generate a buy signal when RSI is below 30 and MACD is above signal line', () => {    const rsi = 25;    const macd = 1;    const signal = 0.5;    const threshold = 30;    const result = generateBuySellSignal(rsi, macd, signal, threshold);    expect(result).toBe('buy');  });  it('should generate a sell signal when RSI is above 70 and MACD is below signal line', () => {    const rsi = 75;    const macd = -1;    const signal = -0.5;    const threshold = 70;    const result = generateBuySellSignal(rsi, macd, signal, threshold);    expect(result).toBe('sell');  });  it('should generate a hold signal when RSI is between 30 and 70 and MACD is around signal line', () => {    const rsi = 50;    const macd = 0.1;    const signal = 0.05;    const threshold = 30;    const result = generateBuySellSignal(rsi, macd, signal, threshold);    expect(result).toBe('hold');  });  it('should handle edge cases like RSI and MACD values outside typical range', () => {    const rsi = 100; //Edge case for RSI    const macd = 10; //Edge case for MACD    const signal = 0.5;    const threshold = 30;    const result = generateBuySellSignal(rsi, macd, signal, threshold);    expect(result).toBe('sell'); // Or throw an error, depending on requirements.  Should be handled gracefully  });  it('should handle NaN or undefined values gracefully', () => {    const rsi = NaN;    const macd = undefined;    const signal = 0.5;    const threshold = 30;    expect(() => generateBuySellSignal(rsi, macd, signal, threshold)).toThrow(); // Expecting an error or specific return value  });  it('should generate a buy signal when RSI is below threshold and MACD is above signal line, regardless of positive/negative MACD values', () => {    const rsi = 25;    const macd = -0.8; // Negative MACD, still above the signal line in this case    const signal = -1;    const threshold = 30;    const result = generateBuySellSignal(rsi, macd, signal, threshold);    expect(result).toBe('buy');  });  it('should use the provided threshold values correctly', () => {      const rsi = 35;      const macd = 0.1;      const signal = 0.05;      const threshold = 35; //Setting the threshold to match the RSI value      const result = generateBuySellSignal(rsi, macd, signal, threshold);      expect(result).toBe('hold');  });});```
[2025-05-16T14:32:23.942Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:32:23.943Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:32:23.943Z] WARN: ‚ö†Ô∏è [TEST - Unit Tests for Signal Generation Logic] Failed on attempt 3: Test generation failed
[2025-05-16T14:32:25.946Z] ERROR: ‚ùå [TEST - Unit Tests for Signal Generation Logic] Failed after 3 retries
[2025-05-16T14:32:25.947Z] ERROR: ‚ùå Testing agent failed permanently: Test generation failed
[2025-05-16T14:32:30.973Z] INFO: üîÅ [TEST - Integration Tests for Email Notifications] Attempt 1 of 3
[2025-05-16T14:32:35.816Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write integration tests to simulate sending email notifications and verify the content and formatting of the emails. Consider using a test email service to avoid spamming the actual recipient.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:32:41.418Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const nodemailer = require('nodemailer');
const { testAgent } = require('./agents/testAgent');

// Mock the nodemailer transporter for testing
jest.mock('nodemailer', () => ({
  createTransport: jest.fn(() => ({
    sendMail: jest.fn((options, callback) => {
      callback(null, { response: 'Email sent successfully' });
    }),
  })),
}));


describe('Email Notification Service', () => {
  it('should send a formatted email with correct content', async () => {
    const mockEmailDat
[2025-05-16T14:32:41.420Z] INFO: üß™ Raw test output:
```javascript
const nodemailer = require('nodemailer');
const { testAgent } = require('./agents/testAgent');

// Mock the nodemailer transporter for testing
jest.mock('nodemailer', () => ({
  createTransport: jest.fn(() => ({
    sendMail: jest.fn((options, callback) => {
      callback(null, { response: 'Email sent successfully' });
    }),
  })),
}));


describe('Email Notification Service', () => {
  it('should send a formatted email with correct content', async () => {
    const mockEmailData = {
      to: 'test@example.com',
      subject: 'Test Email',
      html: '<p>This is a test email.</p>',
    };

    //Simulate the sending email function.  You would replace this with your actual email sending function
    const sendEmail = async (data) => {
        const transporter = nodemailer.createTransport({
            service: 'gmail', // Or your preferred email service
            auth: {
                user: 'your_email@gmail.com',
                pass: 'your_password'
            }
        });
        return await transporter.sendMail(data)
    }

    await expect(sendEmail(mockEmailData)).resolves.toEqual({ response: 'Email sent successfully' });
    expect(nodemailer.createTransport).toHaveBeenCalled();
    expect(nodemailer.createTransport().sendMail).toHaveBeenCalledWith(mockEmailData, expect.any(Function));
  });


  it('should handle errors gracefully', async () => {
    const mockErrorData = {
        to: 'test@example.com',
        subject: 'Test Email',
        html: '<p>This is a test email.</p>',
    };

    //Mock error handling
    nodemailer.createTransport().sendMail.mockImplementationOnce((options, callback) => {
        callback(new Error('Failed to send email'));
    });

    await expect(sendEmail(mockErrorData)).rejects.toThrow('Failed to send email')
  });


  it('should format the email content correctly', async () => {
    const emailData = {
      to: 'test@example.com',
      subject: 'Test Email',
      html: '<p>This is a test email.</p>',
    };

    const sendEmail = async (data) => {
        const transporter = nodemailer.createTransport({
            service: 'gmail', // Or your preferred email service
            auth: {
                user: 'your_email@gmail.com',
                pass: 'your_password'
            }
        });
        const info = await transporter.sendMail(data)
        return info.response
    }

    const result = await sendEmail(emailData);
    expect(result).toContain('Email sent successfully');

  });


  it('should handle empty email data gracefully', async () => {
      const emptyEmailData = {};
      await expect(sendEmail(emptyEmailData)).rejects.toThrow();
  })

});

```

[2025-05-16T14:32:41.422Z] INFO: ‚úÖ Cleaned test output:
const nodemailer = require('nodemailer');const { testAgent } = require('./agents/testAgent');// Mock the nodemailer transporter for testingjest.mock('nodemailer', () => ({  createTransport: jest.fn(() => ({    sendMail: jest.fn((options, callback) => {      callback(null, { response: 'Email sent successfully' });    }),  })),}));describe('Email Notification Service', () => {  it('should send a formatted email with correct content', async () => {    const mockEmailData = {      to: 'test@example.com',      subject: 'Test Email',      html: '<p>This is a test email.</p>',    };    //Simulate the sending email function.  You would replace this with your actual email sending function    const sendEmail = async (data) => {        const transporter = nodemailer.createTransport({            service: 'gmail', // Or your preferred email service            auth: {                user: 'your_email@gmail.com',                pass: 'your_password'            }        });        return await transporter.sendMail(data)    }    await expect(sendEmail(mockEmailData)).resolves.toEqual({ response: 'Email sent successfully' });    expect(nodemailer.createTransport).toHaveBeenCalled();    expect(nodemailer.createTransport().sendMail).toHaveBeenCalledWith(mockEmailData, expect.any(Function));  });  it('should handle errors gracefully', async () => {    const mockErrorData = {        to: 'test@example.com',        subject: 'Test Email',        html: '<p>This is a test email.</p>',    };    //Mock error handling    nodemailer.createTransport().sendMail.mockImplementationOnce((options, callback) => {        callback(new Error('Failed to send email'));    });    await expect(sendEmail(mockErrorData)).rejects.toThrow('Failed to send email')  });  it('should format the email content correctly', async () => {    const emailData = {      to: 'test@example.com',      subject: 'Test Email',      html: '<p>This is a test email.</p>',    };    const sendEmail = async (data) => {        const transporter = nodemailer.createTransport({            service: 'gmail', // Or your preferred email service            auth: {                user: 'your_email@gmail.com',                pass: 'your_password'            }        });        const info = await transporter.sendMail(data)        return info.response    }    const result = await sendEmail(emailData);    expect(result).toContain('Email sent successfully');  });  it('should handle empty email data gracefully', async () => {      const emptyEmailData = {};      await expect(sendEmail(emptyEmailData)).rejects.toThrow();  })});```
[2025-05-16T14:32:41.422Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:32:41.423Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:32:41.423Z] WARN: ‚ö†Ô∏è [TEST - Integration Tests for Email Notifications] Failed on attempt 1: Test generation failed
[2025-05-16T14:32:41.924Z] INFO: üîÅ [TEST - Integration Tests for Email Notifications] Attempt 2 of 3
[2025-05-16T14:32:46.875Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write integration tests to simulate sending email notifications and verify the content and formatting of the emails. Consider using a test email service to avoid spamming the actual recipient.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:32:54.156Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const nodemailer = require('nodemailer');
const { EMAIL_HOST, EMAIL_PORT, EMAIL_USER, EMAIL_PASS } = process.env;

describe('Email Notifications', () => {
  let transporter;

  beforeAll(() => {
    // Mock transporter for testing
    transporter = nodemailer.createTransport({
      host: EMAIL_HOST || 'smtp.ethereal.email',
      port: EMAIL_PORT || 587,
      secure: false, // true for 465, false for other ports
      auth: {
        user: EMAIL_USER || 'test@example.com', // gen
[2025-05-16T14:32:54.157Z] INFO: üß™ Raw test output:
```javascript
const nodemailer = require('nodemailer');
const { EMAIL_HOST, EMAIL_PORT, EMAIL_USER, EMAIL_PASS } = process.env;

describe('Email Notifications', () => {
  let transporter;

  beforeAll(() => {
    // Mock transporter for testing
    transporter = nodemailer.createTransport({
      host: EMAIL_HOST || 'smtp.ethereal.email',
      port: EMAIL_PORT || 587,
      secure: false, // true for 465, false for other ports
      auth: {
        user: EMAIL_USER || 'test@example.com', // generated ethereal user
        pass: EMAIL_PASS || 'testpassword', // generated ethereal password
      },
    });
  });


  it('should send a welcome email with correct content', async () => {
    const testEmail = {
      to: 'testuser@example.com',
      subject: 'Welcome to Our App!',
      html: '<h1>Welcome!</h1><p>Thank you for signing up.</p>',
    };

    const info = await transporter.sendMail(testEmail);
    expect(info.messageId).toBeDefined();
    expect(info.accepted).toContain(testEmail.to); // Check if email was accepted
    // Optionally, fetch the email from the test email service (e.g., Ethereal) and check the content
  });


  it('should handle errors gracefully when sending email', async () => {
    //Simulate an error - incorrect email address
    const badEmail = {
      to: 'incorrect-email',
      subject: 'Test Email',
      html: '<h1>This is a test</h1>',
    };
    await expect(transporter.sendMail(badEmail)).rejects.toThrow(); //Expect rejection/error
  });

  it('should format emails correctly with HTML and attachments', async () => {
    const emailWithAttachment = {
      to: 'testuser@example.com',
      subject: 'Email with Attachment',
      html: '<p>This email has an attachment.</p>',
      attachments: [{
        filename: 'test.txt',
        content: 'This is a test file.',
      }],
    };
    const info = await transporter.sendMail(emailWithAttachment);
    expect(info.messageId).toBeDefined();
    expect(info.accepted).toContain(emailWithAttachment.to);  // Check if email was accepted

    //Use a test email service to verify the attachment was received correctly.  This requires an additional step using the email service API, not shown here.

  });

  it('should send emails with correct subject lines based on event type', async () => {
    const eventEmail = {
      to: 'testuser@example.com',
      subject: 'Order Confirmation #123', // Subject line specific to event
      html: '<p>Your order has been confirmed.</p>',
    };
    const info = await transporter.sendMail(eventEmail);
    expect(info.messageId).toBeDefined();
    expect(info.accepted).toContain(eventEmail.to); //Check if email was accepted
    expect(info.subject).toBe(eventEmail.subject); // Check the subject line specifically

  });



  // Add more tests for various scenarios, such as:
  // - Different email types (e.g., password reset, order confirmation)
  // - Handling invalid email addresses
  // - Testing different formatting options (e.g., plain text emails)
  // - Testing email delivery success and failure.
});

```

[2025-05-16T14:32:54.158Z] INFO: ‚úÖ Cleaned test output:
const nodemailer = require('nodemailer');const { EMAIL_HOST, EMAIL_PORT, EMAIL_USER, EMAIL_PASS } = process.env;describe('Email Notifications', () => {  let transporter;  beforeAll(() => {    // Mock transporter for testing    transporter = nodemailer.createTransport({      host: EMAIL_HOST || 'smtp.ethereal.email',      port: EMAIL_PORT || 587,      secure: false, // true for 465, false for other ports      auth: {        user: EMAIL_USER || 'test@example.com', // generated ethereal user        pass: EMAIL_PASS || 'testpassword', // generated ethereal password      },    });  });  it('should send a welcome email with correct content', async () => {    const testEmail = {      to: 'testuser@example.com',      subject: 'Welcome to Our App!',      html: '<h1>Welcome!</h1><p>Thank you for signing up.</p>',    };    const info = await transporter.sendMail(testEmail);    expect(info.messageId).toBeDefined();    expect(info.accepted).toContain(testEmail.to); // Check if email was accepted    // Optionally, fetch the email from the test email service (e.g., Ethereal) and check the content  });  it('should handle errors gracefully when sending email', async () => {    //Simulate an error - incorrect email address    const badEmail = {      to: 'incorrect-email',      subject: 'Test Email',      html: '<h1>This is a test</h1>',    };    await expect(transporter.sendMail(badEmail)).rejects.toThrow(); //Expect rejection/error  });  it('should format emails correctly with HTML and attachments', async () => {    const emailWithAttachment = {      to: 'testuser@example.com',      subject: 'Email with Attachment',      html: '<p>This email has an attachment.</p>',      attachments: [{        filename: 'test.txt',        content: 'This is a test file.',      }],    };    const info = await transporter.sendMail(emailWithAttachment);    expect(info.messageId).toBeDefined();    expect(info.accepted).toContain(emailWithAttachment.to);  // Check if email was accepted    //Use a test email service to verify the attachment was received correctly.  This requires an additional step using the email service API, not shown here.  });  it('should send emails with correct subject lines based on event type', async () => {    const eventEmail = {      to: 'testuser@example.com',      subject: 'Order Confirmation #123', // Subject line specific to event      html: '<p>Your order has been confirmed.</p>',    };    const info = await transporter.sendMail(eventEmail);    expect(info.messageId).toBeDefined();    expect(info.accepted).toContain(eventEmail.to); //Check if email was accepted    expect(info.subject).toBe(eventEmail.subject); // Check the subject line specifically  });  // Add more tests for various scenarios, such as:  // - Different email types (e.g., password reset, order confirmation)  // - Handling invalid email addresses  // - Testing different formatting options (e.g., plain text emails)  // - Testing email delivery success and failure.});```
[2025-05-16T14:32:54.159Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:32:54.160Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:32:54.160Z] WARN: ‚ö†Ô∏è [TEST - Integration Tests for Email Notifications] Failed on attempt 2: Test generation failed
[2025-05-16T14:32:55.161Z] INFO: üîÅ [TEST - Integration Tests for Email Notifications] Attempt 3 of 3
[2025-05-16T14:33:00.152Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Write integration tests to simulate sending email notifications and verify the content and formatting of the emails. Consider using a test email service to avoid spamming the actual recipient.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:33:06.909Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const {mockSendMail} = require('./mockMailer'); // Assuming a mock email sending function exists.  Create this file if it doesn't.

describe('Email Notification Service', () => {
  beforeEach(() => {
    mockSendMail.mockClear(); // Clear mocks before each test
  });

  it('should send a registration email with correct content', async () => {
    const user = { name: 'Test User', email: 'test@example.com' };
    // Assuming a sendRegistrationEmail function exists. Replace with your
[2025-05-16T14:33:06.910Z] INFO: üß™ Raw test output:
```javascript
const {mockSendMail} = require('./mockMailer'); // Assuming a mock email sending function exists.  Create this file if it doesn't.

describe('Email Notification Service', () => {
  beforeEach(() => {
    mockSendMail.mockClear(); // Clear mocks before each test
  });

  it('should send a registration email with correct content', async () => {
    const user = { name: 'Test User', email: 'test@example.com' };
    // Assuming a sendRegistrationEmail function exists. Replace with your actual function.
    await sendRegistrationEmail(user); 
    expect(mockSendMail).toHaveBeenCalledWith(user.email, expect.stringContaining('Welcome, Test User!'), expect.stringContaining('Thank you for registering.'));
  });


  it('should handle invalid email addresses', async () => {
    const user = { name: 'Test User', email: 'invalid-email' };
    await expect(sendRegistrationEmail(user)).rejects.toThrow('Invalid email address'); //Replace with your actual error handling
  });


  it('should send a password reset email with correct content', async () => {
    const email = 'test@example.com';
    const resetToken = '12345';
    await sendPasswordResetEmail(email, resetToken);
    expect(mockSendMail).toHaveBeenCalledWith(email, expect.stringContaining('Password Reset Request'), expect.stringContaining('Your reset token is: 12345'));
  });

  it('should handle missing email parameters gracefully', async () => {
    await expect(sendPasswordResetEmail(null, '12345')).rejects.toThrow('Email address is required'); //replace with your actual error handling
    await expect(sendPasswordResetEmail('test@example.com', null)).rejects.toThrow('Reset token is required'); //replace with your actual error handling
  });


  it('should send an email with custom subject and body', async () => {
    const subject = 'Custom Email Subject';
    const body = 'Custom email body';
    const to = 'test@example.com';
    await sendCustomEmail(to,subject,body);
    expect(mockSendMail).toHaveBeenCalledWith(to, subject, body);
  });

  it('should handle errors during email sending', async () => {
    mockSendMail.mockRejectedValueOnce(new Error('Email sending failed'));
    const user = { name: 'Test User', email: 'test@example.com' };
    await expect(sendRegistrationEmail(user)).rejects.toThrow('Email sending failed');
  });
});

```

[2025-05-16T14:33:06.911Z] INFO: ‚úÖ Cleaned test output:
const {mockSendMail} = require('./mockMailer'); // Assuming a mock email sending function exists.  Create this file if it doesn't.describe('Email Notification Service', () => {  beforeEach(() => {    mockSendMail.mockClear(); // Clear mocks before each test  });  it('should send a registration email with correct content', async () => {    const user = { name: 'Test User', email: 'test@example.com' };    // Assuming a sendRegistrationEmail function exists. Replace with your actual function.    await sendRegistrationEmail(user);     expect(mockSendMail).toHaveBeenCalledWith(user.email, expect.stringContaining('Welcome, Test User!'), expect.stringContaining('Thank you for registering.'));  });  it('should handle invalid email addresses', async () => {    const user = { name: 'Test User', email: 'invalid-email' };    await expect(sendRegistrationEmail(user)).rejects.toThrow('Invalid email address'); //Replace with your actual error handling  });  it('should send a password reset email with correct content', async () => {    const email = 'test@example.com';    const resetToken = '12345';    await sendPasswordResetEmail(email, resetToken);    expect(mockSendMail).toHaveBeenCalledWith(email, expect.stringContaining('Password Reset Request'), expect.stringContaining('Your reset token is: 12345'));  });  it('should handle missing email parameters gracefully', async () => {    await expect(sendPasswordResetEmail(null, '12345')).rejects.toThrow('Email address is required'); //replace with your actual error handling    await expect(sendPasswordResetEmail('test@example.com', null)).rejects.toThrow('Reset token is required'); //replace with your actual error handling  });  it('should send an email with custom subject and body', async () => {    const subject = 'Custom Email Subject';    const body = 'Custom email body';    const to = 'test@example.com';    await sendCustomEmail(to,subject,body);    expect(mockSendMail).toHaveBeenCalledWith(to, subject, body);  });  it('should handle errors during email sending', async () => {    mockSendMail.mockRejectedValueOnce(new Error('Email sending failed'));    const user = { name: 'Test User', email: 'test@example.com' };    await expect(sendRegistrationEmail(user)).rejects.toThrow('Email sending failed');  });});```
[2025-05-16T14:33:06.912Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:33:06.912Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:33:06.912Z] WARN: ‚ö†Ô∏è [TEST - Integration Tests for Email Notifications] Failed on attempt 3: Test generation failed
[2025-05-16T14:33:08.914Z] ERROR: ‚ùå [TEST - Integration Tests for Email Notifications] Failed after 3 retries
[2025-05-16T14:33:08.915Z] ERROR: ‚ùå Testing agent failed permanently: Test generation failed
[2025-05-16T14:33:13.599Z] INFO: üîÅ [TEST - End-to-End Tests] Attempt 1 of 3
[2025-05-16T14:33:18.211Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Develop end-to-end tests to simulate a complete workflow from price data fetching to signal generation and email notification, verifying the entire system's functionality.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:33:26.511Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { fetchData } = require('./dataFetcher'); // Assuming this fetches price data
const { generateSignals } = require('./signalGenerator'); // Assumes signal generation logic
const { sendEmail } = require('./emailSender'); // Assumes email sending functionality

jest.mock('./dataFetcher');
jest.mock('./signalGenerator');
jest.mock('./emailSender');


describe('End-to-End Workflow', () => {
  it('should successfully fetch data, generate signals, and send email notification', async
[2025-05-16T14:33:26.512Z] INFO: üß™ Raw test output:
```javascript
const { fetchData } = require('./dataFetcher'); // Assuming this fetches price data
const { generateSignals } = require('./signalGenerator'); // Assumes signal generation logic
const { sendEmail } = require('./emailSender'); // Assumes email sending functionality

jest.mock('./dataFetcher');
jest.mock('./signalGenerator');
jest.mock('./emailSender');


describe('End-to-End Workflow', () => {
  it('should successfully fetch data, generate signals, and send email notification', async () => {
    // Mock data fetching
    const mockData = { price: 100, volume: 1000 };
    fetchData.mockResolvedValue(mockData);

    // Mock signal generation
    const mockSignals = { buy: true, sell: false };
    generateSignals.mockReturnValue(mockSignals);

    // Mock email sending
    sendEmail.mockResolvedValue(true);

    // Simulate workflow
    const result = await simulateWorkflow();

    // Assertions
    expect(fetchData).toHaveBeenCalledTimes(1);
    expect(generateSignals).toHaveBeenCalledWith(mockData);
    expect(sendEmail).toHaveBeenCalledWith(mockSignals);
    expect(result).toBe(true);
  });

  it('should handle errors during data fetching gracefully', async () => {
    fetchData.mockRejectedValue(new Error('Failed to fetch data'));

    try {
      await simulateWorkflow();
      fail('Expected an error'); // fail if no error is thrown
    } catch (error) {
      expect(fetchData).toHaveBeenCalledTimes(1);
      expect(generateSignals).not.toHaveBeenCalled();
      expect(sendEmail).not.toHaveBeenCalled();
      expect(error.message).toEqual('Failed to fetch data');
    }
  });


  it('should handle errors during signal generation gracefully', async () => {
    fetchData.mockResolvedValue({ price: 100, volume: 1000 });
    generateSignals.mockRejectedValue(new Error('Failed to generate signals'));

    try {
      await simulateWorkflow();
      fail('Expected an error');
    } catch (error) {
      expect(fetchData).toHaveBeenCalledTimes(1);
      expect(generateSignals).toHaveBeenCalledTimes(1);
      expect(sendEmail).not.toHaveBeenCalled();
      expect(error.message).toEqual('Failed to generate signals');
    }
  });

  it('should handle errors during email sending gracefully', async () => {
    fetchData.mockResolvedValue({ price: 100, volume: 1000 });
    generateSignals.mockReturnValue({ buy: true, sell: false });
    sendEmail.mockRejectedValue(new Error('Failed to send email'));

    try {
      await simulateWorkflow();
      fail('Expected an error');
    } catch (error) {
      expect(fetchData).toHaveBeenCalledTimes(1);
      expect(generateSignals).toHaveBeenCalledTimes(1);
      expect(sendEmail).toHaveBeenCalledTimes(1);
      expect(error.message).toEqual('Failed to send email');
    }
  });

  it('should handle empty data from fetchData gracefully', async () => {
    fetchData.mockResolvedValue({});

    try {
      await simulateWorkflow();
      fail('Expected an error');
    } catch (error) {
      expect(fetchData).toHaveBeenCalledTimes(1);
      expect(generateSignals).not.toHaveBeenCalled();
      expect(sendEmail).not.toHaveBeenCalled();
      expect(error.message).toEqual('Invalid or empty data received from fetchData');
    }
  });

});


async function simulateWorkflow() {
  try {
    const data = await fetchData();
    if(Object.keys(data).length === 0) throw new Error("Invalid or empty data received from fetchData");
    const signals = generateSignals(data);
    const emailSent = await sendEmail(signals);
    return emailSent;
  } catch (error) {
    throw error;
  }
}
```

[2025-05-16T14:33:26.512Z] INFO: ‚úÖ Cleaned test output:
const { fetchData } = require('./dataFetcher'); // Assuming this fetches price dataconst { generateSignals } = require('./signalGenerator'); // Assumes signal generation logicconst { sendEmail } = require('./emailSender'); // Assumes email sending functionalityjest.mock('./dataFetcher');jest.mock('./signalGenerator');jest.mock('./emailSender');describe('End-to-End Workflow', () => {  it('should successfully fetch data, generate signals, and send email notification', async () => {    // Mock data fetching    const mockData = { price: 100, volume: 1000 };    fetchData.mockResolvedValue(mockData);    // Mock signal generation    const mockSignals = { buy: true, sell: false };    generateSignals.mockReturnValue(mockSignals);    // Mock email sending    sendEmail.mockResolvedValue(true);    // Simulate workflow    const result = await simulateWorkflow();    // Assertions    expect(fetchData).toHaveBeenCalledTimes(1);    expect(generateSignals).toHaveBeenCalledWith(mockData);    expect(sendEmail).toHaveBeenCalledWith(mockSignals);    expect(result).toBe(true);  });  it('should handle errors during data fetching gracefully', async () => {    fetchData.mockRejectedValue(new Error('Failed to fetch data'));    try {      await simulateWorkflow();      fail('Expected an error'); // fail if no error is thrown    } catch (error) {      expect(fetchData).toHaveBeenCalledTimes(1);      expect(generateSignals).not.toHaveBeenCalled();      expect(sendEmail).not.toHaveBeenCalled();      expect(error.message).toEqual('Failed to fetch data');    }  });  it('should handle errors during signal generation gracefully', async () => {    fetchData.mockResolvedValue({ price: 100, volume: 1000 });    generateSignals.mockRejectedValue(new Error('Failed to generate signals'));    try {      await simulateWorkflow();      fail('Expected an error');    } catch (error) {      expect(fetchData).toHaveBeenCalledTimes(1);      expect(generateSignals).toHaveBeenCalledTimes(1);      expect(sendEmail).not.toHaveBeenCalled();      expect(error.message).toEqual('Failed to generate signals');    }  });  it('should handle errors during email sending gracefully', async () => {    fetchData.mockResolvedValue({ price: 100, volume: 1000 });    generateSignals.mockReturnValue({ buy: true, sell: false });    sendEmail.mockRejectedValue(new Error('Failed to send email'));    try {      await simulateWorkflow();      fail('Expected an error');    } catch (error) {      expect(fetchData).toHaveBeenCalledTimes(1);      expect(generateSignals).toHaveBeenCalledTimes(1);      expect(sendEmail).toHaveBeenCalledTimes(1);      expect(error.message).toEqual('Failed to send email');    }  });  it('should handle empty data from fetchData gracefully', async () => {    fetchData.mockResolvedValue({});    try {      await simulateWorkflow();      fail('Expected an error');    } catch (error) {      expect(fetchData).toHaveBeenCalledTimes(1);      expect(generateSignals).not.toHaveBeenCalled();      expect(sendEmail).not.toHaveBeenCalled();      expect(error.message).toEqual('Invalid or empty data received from fetchData');    }  });});async function simulateWorkflow() {  try {    const data = await fetchData();    if(Object.keys(data).length === 0) throw new Error("Invalid or empty data received from fetchData");    const signals = generateSignals(data);    const emailSent = await sendEmail(signals);    return emailSent;  } catch (error) {    throw error;  }}```
[2025-05-16T14:33:26.513Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:33:26.513Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:33:26.513Z] WARN: ‚ö†Ô∏è [TEST - End-to-End Tests] Failed on attempt 1: Test generation failed
[2025-05-16T14:33:27.015Z] INFO: üîÅ [TEST - End-to-End Tests] Attempt 2 of 3
[2025-05-16T14:33:32.119Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Develop end-to-end tests to simulate a complete workflow from price data fetching to signal generation and email notification, verifying the entire system's functionality.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:33:42.187Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { fetchData } = require('./fetchData'); // Mock this
const { generateSignals } = require('./generateSignals'); // Mock this
const { sendEmail } = require('./sendEmail'); // Mock this

describe('End-to-End Workflow', () => {
  it('should successfully fetch data, generate signals, and send an email notification', async () => {
    // Mock external dependencies
    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({
      priceData: [10, 12, 15, 14, 16],
[2025-05-16T14:33:42.189Z] INFO: üß™ Raw test output:
```javascript
const { fetchData } = require('./fetchData'); // Mock this
const { generateSignals } = require('./generateSignals'); // Mock this
const { sendEmail } = require('./sendEmail'); // Mock this

describe('End-to-End Workflow', () => {
  it('should successfully fetch data, generate signals, and send an email notification', async () => {
    // Mock external dependencies
    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({
      priceData: [10, 12, 15, 14, 16], // Example price data
    });

    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals').mockResolvedValue({
      signals: ['buy', 'hold', 'sell'], // Example signals
    });

    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail').mockResolvedValue(true);

    // Simulate workflow
    const result = await fetchData();
    const signals = await generateSignals(result.priceData);
    const emailSent = await sendEmail(signals);

    // Assertions
    expect(mockFetchData).toHaveBeenCalledTimes(1);
    expect(mockGenerateSignals).toHaveBeenCalledTimes(1);
    expect(mockGenerateSignals).toHaveBeenCalledWith([10, 12, 15, 14, 16]);
    expect(mockSendEmail).toHaveBeenCalledTimes(1);
    expect(mockSendEmail).toHaveBeenCalledWith(['buy', 'hold', 'sell']);
    expect(emailSent).toBe(true);
    mockFetchData.mockRestore();
    mockGenerateSignals.mockRestore();
    mockSendEmail.mockRestore();
  });


  it('should handle errors during data fetching gracefully', async () => {
    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockRejectedValue(new Error('Failed to fetch data'));
    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals');
    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail');

    try {
      await fetchData();
      fail('Expected fetchData to throw an error');
    } catch (error) {
      expect(mockFetchData).toHaveBeenCalledTimes(1);
      expect(mockGenerateSignals).not.toHaveBeenCalled();
      expect(mockSendEmail).not.toHaveBeenCalled();
      expect(error.message).toBe('Failed to fetch data');
    } finally {
      mockFetchData.mockRestore();
      mockGenerateSignals.mockRestore();
      mockSendEmail.mockRestore();
    }
  });

  it('should handle errors during signal generation gracefully', async () => {
    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({ priceData: [10, 12, 15] });
    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals').mockRejectedValue(new Error('Failed to generate signals'));
    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail');

    try {
      await fetchData();
      await generateSignals([10,12,15]);
      fail('Expected generateSignals to throw an error');
    } catch (error) {
      expect(mockFetchData).toHaveBeenCalledTimes(1);
      expect(mockGenerateSignals).toHaveBeenCalledTimes(1);
      expect(mockSendEmail).not.toHaveBeenCalled();
      expect(error.message).toBe('Failed to generate signals');
    } finally {
      mockFetchData.mockRestore();
      mockGenerateSignals.mockRestore();
      mockSendEmail.mockRestore();
    }
  });

  it('should handle errors during email sending gracefully', async () => {
    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({ priceData: [10, 12, 15] });
    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals').mockResolvedValue({ signals: ['buy'] });
    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail').mockRejectedValue(new Error('Failed to send email'));

    try {
      await fetchData();
      await generateSignals([10,12,15]);
      await sendEmail(['buy']);
      fail('Expected sendEmail to throw an error');
    } catch (error) {
      expect(mockFetchData).toHaveBeenCalledTimes(1);
      expect(mockGenerateSignals).toHaveBeenCalledTimes(1);
      expect(mockSendEmail).toHaveBeenCalledTimes(1);
      expect(error.message).toBe('Failed to send email');
    } finally {
      mockFetchData.mockRestore();
      mockGenerateSignals.mockRestore();
      mockSendEmail.mockRestore();
    }
  });

  it('should handle empty price data', async () => {
    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({ priceData: [] });
    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals');
    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail');

    try {
      await fetchData();
      await generateSignals([]);
      expect(mockGenerateSignals).toHaveBeenCalledWith([]); // Expect generateSignals to handle empty array
    } finally {
      mockFetchData.mockRestore();
      mockGenerateSignals.mockRestore();
      mockSendEmail.mockRestore();
    }
  });
});

```

[2025-05-16T14:33:42.189Z] INFO: ‚úÖ Cleaned test output:
const { fetchData } = require('./fetchData'); // Mock thisconst { generateSignals } = require('./generateSignals'); // Mock thisconst { sendEmail } = require('./sendEmail'); // Mock thisdescribe('End-to-End Workflow', () => {  it('should successfully fetch data, generate signals, and send an email notification', async () => {    // Mock external dependencies    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({      priceData: [10, 12, 15, 14, 16], // Example price data    });    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals').mockResolvedValue({      signals: ['buy', 'hold', 'sell'], // Example signals    });    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail').mockResolvedValue(true);    // Simulate workflow    const result = await fetchData();    const signals = await generateSignals(result.priceData);    const emailSent = await sendEmail(signals);    // Assertions    expect(mockFetchData).toHaveBeenCalledTimes(1);    expect(mockGenerateSignals).toHaveBeenCalledTimes(1);    expect(mockGenerateSignals).toHaveBeenCalledWith([10, 12, 15, 14, 16]);    expect(mockSendEmail).toHaveBeenCalledTimes(1);    expect(mockSendEmail).toHaveBeenCalledWith(['buy', 'hold', 'sell']);    expect(emailSent).toBe(true);    mockFetchData.mockRestore();    mockGenerateSignals.mockRestore();    mockSendEmail.mockRestore();  });  it('should handle errors during data fetching gracefully', async () => {    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockRejectedValue(new Error('Failed to fetch data'));    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals');    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail');    try {      await fetchData();      fail('Expected fetchData to throw an error');    } catch (error) {      expect(mockFetchData).toHaveBeenCalledTimes(1);      expect(mockGenerateSignals).not.toHaveBeenCalled();      expect(mockSendEmail).not.toHaveBeenCalled();      expect(error.message).toBe('Failed to fetch data');    } finally {      mockFetchData.mockRestore();      mockGenerateSignals.mockRestore();      mockSendEmail.mockRestore();    }  });  it('should handle errors during signal generation gracefully', async () => {    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({ priceData: [10, 12, 15] });    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals').mockRejectedValue(new Error('Failed to generate signals'));    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail');    try {      await fetchData();      await generateSignals([10,12,15]);      fail('Expected generateSignals to throw an error');    } catch (error) {      expect(mockFetchData).toHaveBeenCalledTimes(1);      expect(mockGenerateSignals).toHaveBeenCalledTimes(1);      expect(mockSendEmail).not.toHaveBeenCalled();      expect(error.message).toBe('Failed to generate signals');    } finally {      mockFetchData.mockRestore();      mockGenerateSignals.mockRestore();      mockSendEmail.mockRestore();    }  });  it('should handle errors during email sending gracefully', async () => {    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({ priceData: [10, 12, 15] });    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals').mockResolvedValue({ signals: ['buy'] });    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail').mockRejectedValue(new Error('Failed to send email'));    try {      await fetchData();      await generateSignals([10,12,15]);      await sendEmail(['buy']);      fail('Expected sendEmail to throw an error');    } catch (error) {      expect(mockFetchData).toHaveBeenCalledTimes(1);      expect(mockGenerateSignals).toHaveBeenCalledTimes(1);      expect(mockSendEmail).toHaveBeenCalledTimes(1);      expect(error.message).toBe('Failed to send email');    } finally {      mockFetchData.mockRestore();      mockGenerateSignals.mockRestore();      mockSendEmail.mockRestore();    }  });  it('should handle empty price data', async () => {    const mockFetchData = jest.spyOn(fetchData, 'fetchData').mockResolvedValue({ priceData: [] });    const mockGenerateSignals = jest.spyOn(generateSignals, 'generateSignals');    const mockSendEmail = jest.spyOn(sendEmail, 'sendEmail');    try {      await fetchData();      await generateSignals([]);      expect(mockGenerateSignals).toHaveBeenCalledWith([]); // Expect generateSignals to handle empty array    } finally {      mockFetchData.mockRestore();      mockGenerateSignals.mockRestore();      mockSendEmail.mockRestore();    }  });});```
[2025-05-16T14:33:42.190Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:33:42.190Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:33:42.191Z] WARN: ‚ö†Ô∏è [TEST - End-to-End Tests] Failed on attempt 2: Test generation failed
[2025-05-16T14:33:43.192Z] INFO: üîÅ [TEST - End-to-End Tests] Attempt 3 of 3
[2025-05-16T14:33:48.099Z] INFO: üß† Gemini Prompt Sent:
You are an expert QA engineer writing Jest test cases.

--- TASK ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


---
Task:
Develop end-to-end tests to simulate a complete workflow from price data fetching to signal generation and email notification, verifying the entire system's functionality.

--- EXISTING TEST CODE ---
üíæ GitHub Repository Context (11 files):

// agents/apiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates clean Express.js backend code using Gemini with repo-wide context.
 *
 * @param {string} subtaskDescription - A backend subtask instruction
 * @returns {Promise<string>} The generated Express route code
 */
async function apiAgent(subtaskDescription) {
  // üîç Load entire repo context (not just backend folder)
  const repoContext = await loadContextFor();

  const prompt = `
You are a professional Node.js backend engineer.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Reuse existing route or controller patterns if they exist
- Extend logic where appropriate
- Avoid duplicating any route that already exists
- Use Express best practices (validation, status codes, modularization)
- Return clean JavaScript code for the new or modified route

Return only code inside one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üîß API Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå API agent failed:", err.message);
    throw new Error("API agent failed to generate code.");
  }
}

module.exports = { apiAgent };


// agents/gemini.js
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

async function generateCode(prompt) {
  const result = await model.generateContent({
    contents: [{ role: 'user', parts: [{ text: prompt }] }]
  });
  return result.response.text();
}

module.exports = { generateCode };


// agents/planner.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

async function plannerAgent(jiraInput) {
  const backendContext = await loadContextFor('Backend');
  const frontendContext = await loadContextFor('Frontend');
  const testingContext = await loadContextFor('Testing');

  const prompt = `
You are a senior AI software architect.

Given the following Jira story, break it into implementation subtasks.

--- JIRA STORY ---
Summary: ${jiraInput.summary}
Description: ${jiraInput.description}

--- EXISTING CONTEXT ---
üîß Backend Routes:
${backendContext}

üé® Frontend Components:
${frontendContext}

üß™ Test Cases:
${testingContext}

--- INSTRUCTIONS ---
‚úÖ Only include subtasks for functionality that is missing or needs extension.
‚úÖ Output a JSON array with objects in this structure:

{
  "component": "Frontend" | "Backend" | "Database" | "Testing",
  "summary": "short task title",
  "description": "1-3 sentence explanation of the task"
}
`;

  try {
    let response = await generateCode(prompt);
    console.log("üìå Planner Output:\n", response);

    // ‚úÖ Remove markdown code block wrapper if present
    response = response
      .replace(/^```(?:json)?\s*/i, '')  // remove leading ```json or ```
      .replace(/```$/, '')              // remove trailing ```

    const parsed = JSON.parse(response);
    return parsed;
  } catch (err) {
    console.error("‚ùå Planner failed:", err.message);
    throw new Error("Planner agent output is not valid JSON array");
  }
}

module.exports = { plannerAgent };


// agents/testAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates Jest test cases for a given feature and its implementation.
 *
 * @param {string} subtaskDescription - The testing subtask (e.g., "test user registration")
 * @param {string} relatedCodeSnippet - Implementation code to test
 * @returns {Promise<string>} Jest test code
 */
async function testAgent(subtaskDescription, relatedCodeSnippet) {
  // üîç Load full repo context for test coverage awareness
  const repoContext = await loadContextFor();

  const prompt = `
You are an expert QA test engineer writing Jest test cases.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODEBASE ---
${repoContext}

--- FEATURE TO TEST ---
${relatedCodeSnippet}

‚úÖ Your goal:
- Ensure core logic is tested using Jest
- Avoid duplicating any test cases that may already exist
- Focus on unit test coverage: inputs, outputs, edge cases
- Mock external dependencies if needed
- Use clean test structure (describe, it, expect)
- Return only a valid test file

Return only the code in one \`\`\`javascript block.
`;

  try {
    const response = await generateCode(prompt);
    console.log("üß™ Test Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå Test agent failed:", err.message);
    throw new Error("Test generation failed");
  }
}

module.exports = { testAgent };


// agents/uiAgent.js
const { generateCode } = require('./gemini');
const { loadContextFor } = require('../context/githubContextLoader');

/**
 * Generates a clean, non-duplicative React component using Gemini + full repo context.
 *
 * @param {string} subtaskDescription - A description of the UI task
 * @returns {Promise<string>} JSX code for a React component
 */
async function uiAgent(subtaskDescription) {
  // üîç Load entire frontend context
  const repoContext = await loadContextFor(); // loads all files

  const prompt = `
You are a senior React engineer working on a large codebase.

--- TASK ---
${subtaskDescription}

--- EXISTING PROJECT CODE ---
${repoContext}

‚úÖ Instructions:
- Integrate with existing components if applicable
- Reuse folder structure and naming conventions
- Avoid duplicating what's already implemented
- Use modular, clean JSX
- Return only the new component code inside one \`\`\`jsx block
`;

  try {
    const response = await generateCode(prompt);
    console.log("üé® UI Agent Output:\n", response);
    return response;
  } catch (err) {
    console.error("‚ùå UI agent failed:", err.message);
    throw new Error("UI generation failed");
  }
}

module.exports = { uiAgent };


// context/contextLoader.js
const fs = require('fs');
const path = require('path');

function loadContextFor(component) {
  try {
    if (component === 'Frontend') {
      const uiContext = fs.readFileSync(path.join(__dirname, '../frontend/components/index.js'), 'utf8');
      return `Existing UI components:\n${uiContext}`;
    }

    if (component === 'Backend') {
      const routes = fs.readFileSync(path.join(__dirname, '../backend/routes/index.js'), 'utf8');
      return `Existing backend routes:\n${routes}`;
    }

    if (component === 'Testing') {
      const tests = fs.readFileSync(path.join(__dirname, '../tests/summary.txt'), 'utf8');
      return `Existing test files:\n${tests}`;
    }

    return '';
  } catch (err) {
    console.warn(`‚ö†Ô∏è Context not found for ${component}:`, err.message);
    return '';
  }
}

module.exports = { loadContextFor };


// context/githubContextLoader.js
const axios = require('axios');
require('dotenv').config();

const GITHUB_API_BASE = 'https://api.github.com';
const TOKEN = process.env.GITHUB_TOKEN;
const OWNER = process.env.GITHUB_OWNER;
const REPO = process.env.GITHUB_REPO;
const BRANCH = 'main';

const headers = {
  Authorization: `token ${TOKEN}`,
  Accept: 'application/vnd.github.v3.raw'
};

// üîÅ Recursively walk GitHub repo tree and collect all JS/JSX files
async function walkGitHubTree(path = '') {
  const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/contents/${path}?ref=${BRANCH}`;
  try {
    const res = await axios.get(url, { headers });
    const entries = Array.isArray(res.data) ? res.data : [];

    let files = [];

    for (const item of entries) {
      if (item.type === 'file' && /\.(js|jsx)$/.test(item.name)) {
        try {
          const fileRes = await axios.get(item.download_url);
          files.push(`// ${item.path}\n${fileRes.data}`);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Failed to download ${item.path}:`, err.message);
        }
      } else if (item.type === 'dir') {
        const subFiles = await walkGitHubTree(item.path);
        files = files.concat(subFiles);
      }
    }

    return files;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to access ${path}:`, err.response?.statusText || err.message);
    return [];
  }
}

// üîç Public function to load full or targeted context
async function loadContextFor(component = '') {
  const allFiles = await walkGitHubTree();
  if (allFiles.length === 0) return `‚ö†Ô∏è No code found in GitHub repo. Start from scratch.`;

  const filtered =
    component === 'Frontend'
      ? allFiles.filter(f => f.includes('/frontend/'))
      : component === 'Backend'
      ? allFiles.filter(f => f.includes('/backend/'))
      : allFiles;

  return `üíæ GitHub Repository Context (${filtered.length} files):\n\n` + filtered.join('\n\n');
}

module.exports = { loadContextFor };


// index.js
const express = require('express');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const { orchestrate } = require('./orchestrator');

dotenv.config();
const app = express();
app.use(bodyParser.json());

process.on('uncaughtException', (err) => {
  console.error('‚ùóÔ∏è Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason) => {
  console.error('‚ùóÔ∏è Unhandled Promise Rejection:', reason);
});

app.get('/', (req, res) => {
  res.send('LangGraph AI Webhook is live üöÄ');
});

app.post('/api/langgraph/start', async (req, res) => {
  const body = req.body;
  const jiraInput = {
    issueKey: body.issue?.key || 'NO-KEY',
    summary: body.issue?.fields?.summary || 'No summary provided',
    description: body.issue?.fields?.description || 'No description provided',
    labels: body.issue?.fields?.labels || []
  };

  console.log(`üîî Received Jira story: ${jiraInput.issueKey} - ${jiraInput.summary}`);

  try {
    const output = await orchestrate(jiraInput);
    console.log('‚úÖ Agent successfully processed the story');
    res.status(200).json({ status: 'success', output });
  } catch (err) {
    console.error('‚ùå LangGraph orchestration failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

const port = process.env.PORT || 8000;
app.listen(port, () => {
  console.log(`üöÄ Server running at http://localhost:${port}`);
});


// orchestrator.js
const fs = require('fs');
const path = require('path');
const { plannerAgent } = require('./agents/planner');
const { uiAgent } = require('./agents/uiAgent');
const { apiAgent } = require('./agents/apiAgent');
const { testAgent } = require('./agents/testAgent');
// const { dbAgent } = require('./agents/dbAgent'); // (optional)
const { loadContextFor } = require('./context/githubContextLoader'); // NEW: Repo awareness

const OUTPUT_DIR = path.join(__dirname, 'output');
if (!fs.existsSync(OUTPUT_DIR)) fs.mkdirSync(OUTPUT_DIR);

// üîÅ Retry wrapper
async function withRetry(agentFn, input, maxRetries = 3, label = 'agent') {
  let attempt = 0;
  let lastError = null;

  while (attempt < maxRetries) {
    try {
      console.log(`üîÅ [${label}] Attempt ${attempt + 1} of ${maxRetries}`);
      const output = await agentFn(input);
      if (!output || output.trim().length === 0) {
        throw new Error("Empty response");
      }
      return output;
    } catch (err) {
      lastError = err;
      console.warn(`‚ö†Ô∏è [${label}] Failed on attempt ${attempt + 1}:`, err.message);
      attempt++;
    }
  }

  console.error(`‚ùå [${label}] Failed after ${maxRetries} retries`);
  throw lastError;
}

// üßπ Safe filename
function cleanFilename(text, index) {
  const safe = text.toLowerCase().replace(/[^a-z0-9]/gi, '_').slice(0, 40);
  return `Generated_${index + 1}_${safe}.js`;
}

async function orchestrate(jiraInput) {
  console.log("\nüöÄ Starting LangGraph-style agent orchestration...");

  const planJson = await plannerAgent(jiraInput);

  let plan;
  try {
    plan = typeof planJson === 'string' ? JSON.parse(planJson) : planJson;
    if (!Array.isArray(plan)) throw new Error("Planner returned non-array");
  } catch (e) {
    console.error("‚ùå Failed to parse planner output:", e.message);
    throw new Error("Planner agent output is not valid JSON array");
  }

  const generatedFiles = [];

  for (let i = 0; i < plan.length; i++) {
    const task = plan[i];
    const { component, summary, description } = task;

    let outputCode = '';
    let fileLabel = '';

    // üß† Inject context based on component
    const context = loadContextFor(component);
    const promptWithContext = `${context}\n\n---\nTask:\n${description}`;

    try {
      if (component === 'Frontend') {
        outputCode = await withRetry(uiAgent, promptWithContext, 3, `UI - ${summary}`);
        fileLabel = 'ui';
      } else if (component === 'Backend') {
        outputCode = await withRetry(apiAgent, promptWithContext, 3, `API - ${summary}`);
        fileLabel = 'api';
      } else if (component === 'Testing') {
        outputCode = await withRetry(
          (desc) => testAgent(desc, ''), // Optional: pass actual generated source later
          promptWithContext,
          3,
          `TEST - ${summary}`
        );
        fileLabel = 'test';
      } else {
        console.log(`‚ö†Ô∏è Skipping unsupported component: ${component}`);
        continue;
      }

      const fileName = cleanFilename(`${fileLabel}_${summary}`, i);
      fs.writeFileSync(path.join(OUTPUT_DIR, fileName), outputCode);
      generatedFiles.push(fileName);
      console.log(`‚úÖ Saved: ${fileName}`);
    } catch (err) {
      console.error(`‚ùå ${component} agent failed permanently:`, err.message);
    }
  }

  return {
    message: `‚úÖ ${generatedFiles.length} files generated for ${jiraInput.issueKey}`,
    files: generatedFiles
  };
}

module.exports = { orchestrate };


// scripts/pushToGithub.js
const fs = require('fs');
const path = require('path');
const simpleGit = require('simple-git');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

// üîÅ Git + GitHub client for client repo
const clientRepoPath = process.env.CLIENT_REPO_PATH;
if (!clientRepoPath) throw new Error("‚ùå CLIENT_REPO_PATH missing in .env");

const git = simpleGit({ baseDir: clientRepoPath });
const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

const {
  GITHUB_TOKEN,
  GITHUB_OWNER,
  GITHUB_REPO,
  GITHUB_DEFAULT_BRANCH = 'main',
  GITHUB_PR_TARGET_BRANCH = 'main',
} = process.env;

if (!GITHUB_TOKEN || !GITHUB_OWNER || !GITHUB_REPO) {
  throw new Error("üö® Missing GitHub credentials in .env");
}

function createBranchName(jiraId) {
  return `feature/${jiraId.toLowerCase()}`;
}

async function pushToGithub(jiraId) {
  const branchName = createBranchName(jiraId);
  const outputDir = path.join(__dirname, '../output');
  const files = fs.readdirSync(outputDir);
  console.log(`üöÄ Preparing to push ${files.length} files for ${jiraId} to ${GITHUB_REPO}`);

  // Checkout new branch from default/main
  await git.fetch();
  await git.checkoutBranch(branchName, `origin/${GITHUB_DEFAULT_BRANCH}`);
  console.log(`üåø Switched to new branch: ${branchName}`);

  // Copy generated files to the client repo
  for (const file of files) {
    const src = path.join(outputDir, file);
    const dest = path.join(clientRepoPath, file);
    fs.copyFileSync(src, dest);
  }

  await git.add(files);
  await git.commit(`üîß Feature ${jiraId} - AI-generated implementation`);
  await git.push('origin', branchName);
  console.log(`üì§ Code pushed to branch ${branchName}`);

  // Create Pull Request
  const { data: pr } = await octokit.pulls.create({
    owner: GITHUB_OWNER,
    repo: GITHUB_REPO,
    title: `‚ú® ${jiraId} - AI Feature Implementation`,
    head: branchName,
    base: GITHUB_PR_TARGET_BRANCH,
    body: `This PR was auto-generated by LangGraph AI agents.\n\nüîß Feature: ${jiraId}`
  });

  console.log(`‚úÖ PR created: ${pr.html_url}`);
}

const jiraIdArg = process.argv[2];
if (!jiraIdArg) {
  console.error("‚ùå Please provide a Jira ID: node scripts/pushToGithub.js JIRA-123");
  process.exit(1);
}

pushToGithub(jiraIdArg).catch(err => {
  console.error("‚ùå Failed to push to GitHub:", err.message);
  process.exit(1);
});


// tests/testGithubContext.js
const { loadContextFor } = require('../context/githubContextLoader');

(async () => {
  const ctx = await loadContextFor('Backend');
  console.log("üß† Context from GitHub:\n", ctx);
})();


--- FEATURE TO TEST ---
// No implementation code available

‚úÖ Instructions:
- Cover inputs, outputs, edge cases
- Mock external deps as needed
- Use describe(), it(), expect()
- Do NOT duplicate existing tests

Return only the test file code (no markdown fences).
[2025-05-16T14:33:55.548Z] INFO: ‚úÖ Gemini Output Preview:
```javascript
const { fetchData } = require('./fetchData'); // Assuming fetchData function exists
const { generateSignals } = require('./generateSignals'); // Assuming generateSignals function exists
const { sendEmail } = require('./sendEmail'); // Assuming sendEmail function exists

jest.mock('./fetchData');
jest.mock('./generateSignals');
jest.mock('./sendEmail');


describe('End-to-End Workflow Test', () => {
  it('should successfully fetch data, generate signals, and send email notification'
[2025-05-16T14:33:55.549Z] INFO: üß™ Raw test output:
```javascript
const { fetchData } = require('./fetchData'); // Assuming fetchData function exists
const { generateSignals } = require('./generateSignals'); // Assuming generateSignals function exists
const { sendEmail } = require('./sendEmail'); // Assuming sendEmail function exists

jest.mock('./fetchData');
jest.mock('./generateSignals');
jest.mock('./sendEmail');


describe('End-to-End Workflow Test', () => {
  it('should successfully fetch data, generate signals, and send email notification', async () => {
    const mockData = { price: 100, volume: 1000 };
    fetchData.mockResolvedValue(mockData);

    const mockSignals = { buy: true, sell: false };
    generateSignals.mockImplementation((data) => {
      expect(data).toEqual(mockData);
      return mockSignals;
    });

    const mockEmailStatus = 'sent';
    sendEmail.mockImplementation((signals) => {
      expect(signals).toEqual(mockSignals);
      return mockEmailStatus;
    });

    const emailStatus = await endToEndWorkflow(); // Assuming endToEndWorkflow function exists

    expect(fetchData).toHaveBeenCalledTimes(1);
    expect(generateSignals).toHaveBeenCalledTimes(1);
    expect(generateSignals).toHaveBeenCalledWith(mockData);
    expect(sendEmail).toHaveBeenCalledTimes(1);
    expect(sendEmail).toHaveBeenCalledWith(mockSignals);
    expect(emailStatus).toBe(mockEmailStatus);
  });


  it('should handle errors during data fetching', async () => {
    fetchData.mockRejectedValue(new Error('Failed to fetch data'));
    await expect(endToEndWorkflow()).rejects.toThrow('Failed to fetch data');
    expect(generateSignals).not.toHaveBeenCalled();
    expect(sendEmail).not.toHaveBeenCalled();

  });


  it('should handle errors during signal generation', async () => {
    fetchData.mockResolvedValue({ price: 100, volume: 1000 });
    generateSignals.mockRejectedValue(new Error('Failed to generate signals'));
    await expect(endToEndWorkflow()).rejects.toThrow('Failed to generate signals');
    expect(sendEmail).not.toHaveBeenCalled();
  });

  it('should handle errors during email notification', async () => {
    fetchData.mockResolvedValue({ price: 100, volume: 1000 });
    generateSignals.mockReturnValue({ buy: true, sell: false });
    sendEmail.mockRejectedValue(new Error('Failed to send email'));
    await expect(endToEndWorkflow()).rejects.toThrow('Failed to send email');
  });

  it('should handle edge case: empty data from fetch', async () => {
    fetchData.mockResolvedValue({});
    await expect(endToEndWorkflow()).rejects.toThrow('Invalid or empty data received');
    expect(generateSignals).not.toHaveBeenCalled();
    expect(sendEmail).not.toHaveBeenCalled();
  })


  it('should handle edge case: unexpected signal format', async () => {
    fetchData.mockResolvedValue({price:100, volume:1000});
    generateSignals.mockReturnValue({unexpected:"signal"});
    await expect(endToEndWorkflow()).rejects.toThrow('Invalid signal format');
    expect(sendEmail).not.toHaveBeenCalled();
  })

});


async function endToEndWorkflow() {
  try {
    const data = await fetchData();
    if(Object.keys(data).length === 0) throw new Error('Invalid or empty data received');
    const signals = generateSignals(data);
    if(!signals.buy && !signals.sell) throw new Error('Invalid signal format');
    return sendEmail(signals);
  } catch (error) {
    throw error;
  }
}
```

[2025-05-16T14:33:55.551Z] INFO: ‚úÖ Cleaned test output:
const { fetchData } = require('./fetchData'); // Assuming fetchData function existsconst { generateSignals } = require('./generateSignals'); // Assuming generateSignals function existsconst { sendEmail } = require('./sendEmail'); // Assuming sendEmail function existsjest.mock('./fetchData');jest.mock('./generateSignals');jest.mock('./sendEmail');describe('End-to-End Workflow Test', () => {  it('should successfully fetch data, generate signals, and send email notification', async () => {    const mockData = { price: 100, volume: 1000 };    fetchData.mockResolvedValue(mockData);    const mockSignals = { buy: true, sell: false };    generateSignals.mockImplementation((data) => {      expect(data).toEqual(mockData);      return mockSignals;    });    const mockEmailStatus = 'sent';    sendEmail.mockImplementation((signals) => {      expect(signals).toEqual(mockSignals);      return mockEmailStatus;    });    const emailStatus = await endToEndWorkflow(); // Assuming endToEndWorkflow function exists    expect(fetchData).toHaveBeenCalledTimes(1);    expect(generateSignals).toHaveBeenCalledTimes(1);    expect(generateSignals).toHaveBeenCalledWith(mockData);    expect(sendEmail).toHaveBeenCalledTimes(1);    expect(sendEmail).toHaveBeenCalledWith(mockSignals);    expect(emailStatus).toBe(mockEmailStatus);  });  it('should handle errors during data fetching', async () => {    fetchData.mockRejectedValue(new Error('Failed to fetch data'));    await expect(endToEndWorkflow()).rejects.toThrow('Failed to fetch data');    expect(generateSignals).not.toHaveBeenCalled();    expect(sendEmail).not.toHaveBeenCalled();  });  it('should handle errors during signal generation', async () => {    fetchData.mockResolvedValue({ price: 100, volume: 1000 });    generateSignals.mockRejectedValue(new Error('Failed to generate signals'));    await expect(endToEndWorkflow()).rejects.toThrow('Failed to generate signals');    expect(sendEmail).not.toHaveBeenCalled();  });  it('should handle errors during email notification', async () => {    fetchData.mockResolvedValue({ price: 100, volume: 1000 });    generateSignals.mockReturnValue({ buy: true, sell: false });    sendEmail.mockRejectedValue(new Error('Failed to send email'));    await expect(endToEndWorkflow()).rejects.toThrow('Failed to send email');  });  it('should handle edge case: empty data from fetch', async () => {    fetchData.mockResolvedValue({});    await expect(endToEndWorkflow()).rejects.toThrow('Invalid or empty data received');    expect(generateSignals).not.toHaveBeenCalled();    expect(sendEmail).not.toHaveBeenCalled();  })  it('should handle edge case: unexpected signal format', async () => {    fetchData.mockResolvedValue({price:100, volume:1000});    generateSignals.mockReturnValue({unexpected:"signal"});    await expect(endToEndWorkflow()).rejects.toThrow('Invalid signal format');    expect(sendEmail).not.toHaveBeenCalled();  })});async function endToEndWorkflow() {  try {    const data = await fetchData();    if(Object.keys(data).length === 0) throw new Error('Invalid or empty data received');    const signals = generateSignals(data);    if(!signals.buy && !signals.sell) throw new Error('Invalid signal format');    return sendEmail(signals);  } catch (error) {    throw error;  }}```
[2025-05-16T14:33:55.552Z] ERROR: ‚ùå Test agent failed:
[2025-05-16T14:33:55.553Z] ERROR: Error: Test output does not start with describe()
[2025-05-16T14:33:55.553Z] WARN: ‚ö†Ô∏è [TEST - End-to-End Tests] Failed on attempt 3: Test generation failed
[2025-05-16T14:33:57.554Z] ERROR: ‚ùå [TEST - End-to-End Tests] Failed after 3 retries
[2025-05-16T14:33:57.556Z] ERROR: ‚ùå Testing agent failed permanently: Test generation failed
[2025-05-16T14:33:57.557Z] INFO: üì¶ Installing dependencies in output...
[2025-05-16T14:33:57.625Z] ERROR: ‚ùå No package.json found in output directory.
[2025-05-16T14:33:57.630Z] ERROR: ‚ùå Post-generation install failed: Command failed: node scripts/validateDependencies.js
[2025-05-16T14:33:57.987Z] INFO: üì¶ Repo Bitcoin-notifications already exists
